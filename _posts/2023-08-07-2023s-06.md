---
title: 2023학년도 정보올림피아드 여름학교 6일차
author: mathrabbit
date: 2023-08-07 12:00:00 +0900
categories: [Problem Solving, 2023 여름학교]
tags: [camp]
math: true
---

2024-08-07 : 2024s-06 [그리디]

[문제지](https://drive.google.com/drive/folders/1IC8M6mu5eUTFKHzFmrcHMWInTXt5JgtY?usp=sharing)

## 1. 실수 배낭 문제 (00:09:43)

유명한 fractional kanpsack problem이다. 그리디로 해결할 수 있음이 증명되어 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, l;
pair<int, int> arr[303030];
double ans;
 
bool compare(pair<int, int> a, pair<int, int> b) {
    return a.second * b.first > a.first * b.second;
}
 
int main() {
    cin >> n >> l;
    for (int i = 1; i <= n; i++) cin >> arr[i].first >> arr[i].second;
    sort(arr + 1, arr + n + 1, compare);
    for (int i = 1; i <= n; i++) {
        if (l > arr[i].first) {
            ans += arr[i].second;
            l -= arr[i].first;
        }
        else {
            ans += ((double)arr[i].second / arr[i].first) * l;
            break;
        }
    }
    printf("%.10f", ans);
}
```

## 2. 허프만 인코딩 (00:29:32)

허프만 인코딩을 할 때 가능한 최소 길이를 출력하는 문제다. 가장 빈도가 작은 2개를 힙쳐 그 합을 나타내는 새 정점과 연결하는 과정을 반복함으로써 힙을 생성하는 과정을 대표적인 힙 구조인 `std::priority_queue`을 이용해 구현하자. 이후 답은 각 리프 노드의 깊이가 필요한 문자열의 길이가 됨을 이용해 구할 수 있다. 아래 코드는 묶일 때마다 깊이가 증가함을 이용해 더 간단하게 답을 처리한 것이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int n, cnt[26], ans = 0, types = 0;
 
priority_queue< int, vector<int>, greater<int> > pq;
 
int main() {
    cin >> s;
    n = s.length();
    for (int i = 0; i < n; i++) {
        cnt[s[i] - 'A']++;
    }
    for (int i = 0; i < 26; i++) if (cnt[i] > 0) pq.push(cnt[i]);
    if (pq.size() == 1) ans = pq.top();
    while (pq.size() > 1) {
        int a = pq.top(); pq.pop();
        int b = pq.top(); pq.pop();
        ans += a + b;
        pq.push(a + b);
    }
 
    cout << ans << "\n";
}
```

## 3. 회의실 배정 (00:38:29)

현재까지 진행된 회의가 끝난 시간 이후에 시작하고 가장 끝나는 시간이 이른 회의를 먼저 하면 된다. 끝나는 시간 기준으로 정렬해도 되고, 힙 구조를 사용해도 된다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> pii;
int n, arr[505050][2], ans = 0;
 
priority_queue< pii, vector<pii>, greater<pii> > pq;
 
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> arr[i][0] >> arr[i][1];
 
    for (int i = 1; i <= n; i++) pq.push({arr[i][1], arr[i][0]});
    int time = 0;
    while (!pq.empty()) {
        pii sdule = pq.top();
        pq.pop();
        if (sdule.second < time) continue;
        ans++;
        time = sdule.first;
    }
    cout << ans << "\n";
}
```

## 4. 전선 연결 (01:09:57)

$x$좌표 상으로 인접한 두 정점 사이, $y$좌표 상에서 인접한 두 정점 사이, $z$좌표 상에서 인접한 두 정점 사이의 간선으로만 mst가 이루어짐을 증명할 수 있다. 따라서 간선을 $O(N)$개만 고려해여도 되므로 $O(N \log N)$에 해결할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
int n;
struct threeD {
    int x, y, z, idx;
} arr[101010];
 
bool comx(threeD p, threeD q) {
    return p.x < q.x;
}
bool comy(threeD p, threeD q) {
    return p.y < q.y;
}
bool comz(threeD p, threeD q) {
    return p.z < q.z;
}
 
int dis(int i, int j) {
    return min(abs(arr[i].x - arr[j].x), min(abs(arr[i].y - arr[j].y), abs(arr[i].z - arr[j].z)));
}
 
ll ans = 0;
vector< pair<int, pii> > edges;
 
int root[101010];
int _find(int v) {
    if (v == root[v]) return v;
    else return root[v] = _find(root[v]);
}
 
bool _union(int u, int v) {
    u = _find(u);
    v = _find(v);
    if (u == v) return false;
    root[v] = u;
    return true;
}
 
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> arr[i].x >> arr[i].y >> arr[i].z;
    for (int i = 1; i <= n; i++) arr[i].idx = root[i] = i;
    sort(arr + 1, arr + n + 1, comx);
    for (int i = 1; i < n; i++) {
        int u = arr[i].idx, v = arr[i + 1].idx, d = dis(i, i + 1);
        edges.push_back({d, {u, v}});
    }
    sort(arr + 1, arr + n + 1, comy);
    for (int i = 1; i < n; i++) {
        int u = arr[i].idx, v = arr[i + 1].idx, d = dis(i, i + 1);
        edges.push_back({d, {u, v}});
    }
    sort(arr + 1, arr + n + 1, comz);
    for (int i = 1; i < n; i++) {
        int u = arr[i].idx, v = arr[i + 1].idx, d = dis(i, i + 1);
        edges.push_back({d, {u, v}});
    }
 
    sort(edges.begin(), edges.end());
    for (int i = 0; i < edges.size(); i++) {
        if (_union(edges[i].second.first, edges[i].second.second)) {
            ans += edges[i].first;
        }
    }
    cout << ans << "\n";
}
```

## 5. 전선 연결 2 (01:45:38)

이미 연결된 간선을 끊을 때 비용이 발생하므로, 그 간선을 연결하는 비용을 음수로 보자. 그러면 일반적인 mst를 찾는 문제로 환원된다.

mst가 유일하지 않을 조건은 같은 가중치의 두 간선에 대해 둘 중에 하나만 연결될 수 있는 경우인데, 이 경우는 같은 가중치의 간선을 정렬한 순서에 따라 답이 바뀔 것이다. 따라서, 간선의 양쪽 정점쌍의 오름차순 정렬과 내림차순 정렬로 된 각 간선 배열에 대해 mst를 구해 답이 다르면 유일하지 않고, 답이 같으면 유일한 것이다. 

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
int n, m, k;
ll ans = 0;
vector< pair<int, pii> > edges, edge2;
 
bool comA(pair<int, pii> a, pair<int, pii> b) {
    if (a.first == b.first) return a.second < b.second;
    return a.first < b.first;
}
 
bool comB(pair<int, pii> a, pair<int, pii> b) {
    if (a.first == b.first) return a.second > b.second;
    return a.first < b.first;
}
 
int root[101010];
int _find(int v) {
    if (v == root[v]) return v;
    else return root[v] = _find(root[v]);
}
 
bool _union(int u, int v) {
    u = _find(u);
    v = _find(v);
    if (u == v) return false;
    root[v] = u;
    return true;
}
 
vector<pii> mst(vector< pair<int, pii> > E) {
    vector<pii> ret;
    for (int i = 1; i <= n; i++) root[i] = i;
    for (int i = 0; i < E.size(); i++) {
        if (_union(E[i].second.first, E[i].second.second)) {
            ret.push_back(E[i].second);
        }
    }
    sort(ret.begin(), ret.end());
    return ret;
}
 
int main() {
    cin >> n >> m >> k;
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        if (a > b) swap(a, b);
        edges.push_back({-c, {a, b}});
        edge2.push_back({-c, {a, b}});
        ans += c;
    }
    for (int i = 0; i < k; i++) {
        int x, y, w;
        cin >> x >> y >> w;
        if (x > y) swap(x, y);
        edges.push_back({w, {x, y}});
        edge2.push_back({w, {x, y}});
    }
 
    sort(edges.begin(), edges.end(), comA);
    sort(edge2.begin(), edge2.end(), comB);
 
    for (int i = 1; i <= n; i++) root[i] = i;
    for (int i = 0; i < edges.size(); i++) {
        if (_union(edges[i].second.first, edges[i].second.second)) {
            ans += edges[i].first;
        }
    }
 
    cout << ans << " ";
 
    vector<pii> res = mst(edges);
    vector<pii> re2 = mst(edge2);
    if (res == re2) cout << "unique\n";
    else cout << "not unique\n";
}
```

## 7. 나무 (03:44:41)

먼저 문제의 조건을 관찰해보면 리프 노드부터 시작해서 할당하는 것이 최적임을 알 수 있다. 구체적으로 말하면, 서브트리에서 남아 있는 열매를 받아 합친 후, 가장 많은 것부터 개수만큼 주면 된다.

이 과정을 오일러 투어로 선형으로 편 후 세그먼트 트리를 이용해 최댓값을 찾고 최댓값을 제거해 해결할 수 있다. 이 경우에는 시간복잡도 $O(N \log N)$이다.

다른 방법으로는 자식에게 남아 있는 열매 번호를 `std::set`으로 받아 `smaller to larger`로 합치면 $O(N\log N)$번의 원소 이동만 있음이 보장되므로 $O(N \log^2 N)$으로 해결할 수 있다. 

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, par[202020], cnt[202020];
long long ans = 0;
vector<int> child[202020];
 
int r = 0, tour[404040], lt[202020], rt[202020];
void order(int v) {
    tour[++r] = v;
    lt[v] = r;
    for (int i = 0; i < child[v].size(); i++) {
        int next = child[v][i];
        order(next);
        tour[++r] = v;
    }
    rt[v] = r;
}
 
struct node {
    int val, idx;
} tree[2020202];
 
node merger(node lt_val, node rt_val) {
    node ret;
    ret.val = max(lt_val.val, rt_val.val);
    if (lt_val.val > rt_val.val) ret.idx = lt_val.idx;
    if (lt_val.val < rt_val.val) ret.idx = rt_val.idx;
    return ret;
}
 
void init(int v, int st, int ed) {
    if (st == ed) {
        tree[v].val = -1;
        tree[v].idx = st;
        return;
    }
    int mid = (st + ed) / 2;
    init(2 * v, st, mid);
    init(2 * v + 1, mid + 1, ed);
    tree[v] = merger(tree[2 * v], tree[2 * v + 1]);
}
 
void update(int v, int st, int ed, int idx, int val) {
    if (st > idx || ed < idx) return;
    if (st == idx && ed == idx) {
        tree[v].val = val;
        return;
    }
    int mid = (st + ed) / 2;
    update(2 * v, st, mid, idx, val);
    update(2 * v + 1, mid + 1, ed, idx, val);
    tree[v] = merger(tree[2 * v], tree[2 * v + 1]);
}
 
node get(int v, int st, int ed, int lt, int rt) {
    if (lt > ed || rt < st) return {-1, 0};
    if (lt <= st && ed <= rt) return tree[v];
    int mid = (st + ed) / 2;
    return merger(
        get(2 * v, st, mid, lt, rt),
        get(2 * v + 1, mid + 1, ed, lt, rt)
    );
}
 
void DFS(int v) {
    for (int i = 0; i < child[v].size(); i++) {
        int next = child[v][i];
        DFS(next);
    }
    
    for (int i = 0; i < cnt[v]; i++) {
        node ret = get(1, 1, 2*n-1, lt[v], rt[v]);
        if (ret.val == -1) break;
        ans += ret.val;
        update(1, 1, 2*n-1, ret.idx, 0);
    }
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i < n; i++) {
        cin >> par[i];
        child[par[i]].push_back(i);
    }
    for (int i = 1; i <= m; i++) {
        int c; cin >> c; cnt[c]++;
    }
 
    order(0);
    init(1, 1, 2*n-1);
    for (int i = 1; i <= n; i++) update(1, 1, 2*n-1, lt[i], i);
 
    DFS(0);
 
    cout << ans << "\n";
 
    return 0;
}
```

## 10. 터널 (05:25:12)

[백업](https://www.acmicpc.net/problem/1150)과 동일한 문제이다. 대표적인 우선순위 큐를 활용한 그리디 문제이다. 

처음에는 인접하게 붙어있는 두 점을 고르는 것이 최적임을 알 수 있다. 이후에도 인접하게 붙어있는 두 정점을 고르면 되는데, 문제는 그 구간이 기존에 연결된 부분을 포함하는 경우이다. 이 경우에는 기존의 연결 관계를 뒤집는 것이 최적임을 알 수 있으므로, 어떤 두 점을 연결할 때마다 그 바깥을 연결할 때 뒤집어 짐으로써 늘어나는 거리를 추가로 우선순위 큐에 추가하자.

구현을 위해 왼쪽으로 인접한 점, 오른쪽으로 인접한 점, 현재 점의 사용되었는지 여부 등을 관리하여야 한다. 구현이 쉽지 않으니 주의하도록 하자.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> pii;
typedef long long ll;
#define st first
#define ed second
 
int n, k, lt[101010], rt[101010], ch[101010];
ll arr[101010], dis[101010];
 
ll ans = 0;
priority_queue< pair<ll, pii>, vector< pair<ll, pii> >, greater<> > pq;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> arr[i];
    arr[0] = -1e10; arr[n + 1] = +1e10;
 
    dis[1] = arr[1] - arr[0];
    dis[2] = arr[2] - arr[1];
    for (int i = 2; i <= n + 1; i++) dis[i] = dis[i - 2] + arr[i] - arr[i - 1];
 
    for (int i = 1; i <= n + 1; i++) pq.push({arr[i] - arr[i - 1], {i - 1, i}});
    for (int i = 0; i <= n + 1; i++) lt[i] = i - 1;
    for (int i = 0; i <= n + 1; i++) rt[i] = i + 1;
 
    while (k--) {
        while (ch[pq.top().second.st] || ch[pq.top().second.ed]) pq.pop();
        ll d = pq.top().first;
        pii seg = pq.top().second, next;
        pq.pop();
 
        ans += d;
        ch[seg.st] = ch[seg.ed] = 1;
        next.st = lt[seg.st];
        next.ed = rt[seg.ed];
        rt[next.st] = next.ed;
        lt[next.ed] = next.st;
        pq.push({(dis[next.ed] - dis[next.st - 1]) - (dis[next.ed - 1] - dis[next.st]), next});
    }
 
    cout << ans << "\n";
 
    return 0;
}
```

## 6. 주니어정보올림피아드

파라메트릭을 이용하자. $x$개를 만들 수 있는지 판단하면 되고, 이는 그리디를 이용해 쉽게 판단할 수 있다. $x$개의 오른쪽 `I`가 끝의 `I`가 됨은 자명하므로, 앞에서부터 찾은 `JO` 또는 `IO`가 끝의 `I`와 하나씩 대응되어야 한다. 자명하게 $k$번째 앞 부분은 $k$번째 끝 `I`와 대응되어야 한다. 만약 대응되지 않으면 그 이후의 모든 앞 부분과 대응될 수 없어 $x$개를 만들 수 없기 때문이다. (https://www.acmicpc.net/problem/5530)

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string s;

int ch[1010101];
vector<int> v;
bool solve(int x) {
    v.clear();
    for (int i = 0; i < n; i++) ch[i] = 0;
    for (int i = n - 1; i >= 0; i--) if (s[i] == 'I') v.push_back(i);
    if (v.size() < x) return false;
    while (v.size() > x) v.pop_back();

    int p = 0, q = 0;
    for (int i = x - 1; i >= 0; i--) {
        while (p < n && (ch[p] == 1 || s[p] == 'O')) p++;
        while (q < n && (q <= p || ch[q] == 1 || s[q] != 'O')) q++;
        if (q >= v[i]) return false;
        ch[p] = 1;
        ch[q] = 1;
        ch[v[i]] = 1;
    }
    return true;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n >> s;

    int st = 0, ed = n;
    while (st < ed) {
        int mid = (st + ed + 1) / 2;
        if (solve(mid)) st = mid;
        else ed = mid - 1;
    }

    cout << st << "\n";

    return 0;
}
```

## 9. ioi 뷔폐

주어진 조건이 $1$의 개수에서 $-1$의 개수를 뺀 값이 $v_i$ 이상인 것이므로, 모든 빈 값에 $1$을 넣었을 때 가능하면 해가 존재하고, 가능하지 않으면 해가 존재하지 않는 것이다.

사전순으로 앞선 나열을 출력해야 하기 때문에 첫 번째 빈 값부터 $-1$을 넣을 수 있는지 판정하자. 이 판정은 위의 불가능과 관련된 논의를 확장해 빈 칸에 모두 $1$을 넣었을 때 가능한지 여부로 확인할 수 있으며 부분합을 이용해 구현할 수 있다. 

구체적으로 $[l, r]$에 있는 확정적으로 있는 $-1$의 개수를 $k$라 할 때, $r - l + 1 - 2k ≥ v$이면 가능하고, 그렇지 않으면 불가능한 것이다. 

이를 총 $M$개의 조건에 대해 만족하는지 확인해야 하므로 시작 기준으로 정렬해 스위핑하자. 스위핑하는 과정에서 $[l, r]$을 $i=l$인 시점에 넣을텐데, 그 전에 넣은 구간과 동등한 비교를 위해 앞에서 이미 $-1$로 확정된 개수의 2를 곱한 $x$만큼 더해 보정해주자. 그리고 최솟값이 $x+2$ 이상이라면 $-1$이 될 수 있는 것이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, arr[101010], cnt[101010];

struct condition {
    int l, r, v;
} con[101010];
vector< pair<int, int> > add[101010];

priority_queue< pair<int, int>, vector< pair<int, int> >, greater<> > pq;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> arr[i];

    for (int i = 1; i <= m; i++) cin >> con[i].l >> con[i].r >> con[i].v;
    for (int i = 1; i <= n; i++) cnt[i] = cnt[i - 1] + (arr[i] == -1 ? 1 : 0);

    for (int i = 1; i <= m; i++) {
        if (con[i].r - con[i].l + 1 - 2 * (cnt[con[i].r] - cnt[con[i].l - 1]) < con[i].v) {
            cout << "Impossible\n";
            return 0;
        }
    }

    for (int i = 1; i <= m; i++) {
        add[con[i].l].push_back({con[i].r, con[i].v});
    }

    int newm = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < add[i].size(); j++) {
            int st = i, ed = add[i][j].first, v = add[i][j].second;
            pq.push({(ed - st + 1) - 2 * (cnt[ed] - cnt[st - 1]) + 2 * newm - v, ed});
        }
        if (arr[i] != 0) continue;
        while (pq.size() > 0 && pq.top().second < i) pq.pop();
        if (pq.size() > 0 && pq.top().first < 2 * newm + 2) arr[i] = 1;
        else { arr[i] = -1; newm++; }
    }

    for (int i = 1; i <= n; i++) cout << arr[i] << " ";
    cout << "\n";

    return 0;
}
```

## 8. 시설 공사

exchange argument를 사용하자. $(a_1, b_1)$ 쌍과 $(a_2, b_2)$ 쌍이 있을 때를 생각해보자. 각각에서 필요한 컨테이너의 크기는 $\max(a_1, a_1 +a_2-b_1)$과 $\max(a_2, a_1+a_2-b_2)$임을 쉽게 알 수 있다.

이제 문제는 같을 때인데, 다음번에 영향을 주는 값은 뒤에 오는 값이므로 뒤에 오는 값의 $a$를 더 작게 한다. 즉, $a_1 > a_2$가 위 두 값이 같은 경우의 정렬 조건이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define a first
#define b second
int n;
pair<ll, ll> arr[1010101];
ll ans = 0;
 
bool compare(pair<ll, ll> p, pair<ll, ll> q) {
    if (max(p.a, p.a + q.a - p.b) == max(q.a, p.a + q.a - q.b)) return p.a > q.a;
    return max(p.a, p.a + q.a - p.b) < max(q.a, p.a + q.a - q.b);
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> arr[i].a >> arr[i].b;
 
    sort(arr + 1, arr + n + 1, compare);
 
    ll suma = 0, sumb = 0;
    for (int i = 1; i <= n; i++) {
        suma += arr[i].a;
        ans = max(ans, suma - sumb);
        sumb += arr[i].b;
    }
 
    cout << ans << "\n";
 
    return 0;
}
```