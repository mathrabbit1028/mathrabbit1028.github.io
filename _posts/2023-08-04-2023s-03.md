---
title: 2023학년도 정보올림피아드 여름학교 3일차
author: mathrabbit
date: 2023-08-04 12:00:00 +0900
categories: [Problem Solving, 2023 여름학교]
tags: [camp]
math: true
---

2024-08-04 : 2024s-03 [자료구조 1]

[문제지](https://drive.google.com/drive/folders/1FBr79KWqf3nuPoGiOMXXOWGqgh9WTWEC?usp=sharing)

## 2. 스택 (00:51:54)

`r` 하나로 배열을 이용해 구현할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int arr[303030];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;
    int r = -1;
    while (n--) {
        //cout << r << "\n";
        string s;
        cin >> s;
        if (s == "PUSH") {
            int x;
            cin >> x;
            arr[++r] = x;
        }
        if (s == "POP") {
            if (r == -1) cout << r << "\n";
            else cout << arr[r] << "\n";
            r = max(r - 1, -1);
        }
        if (s == "TOP") {
            if (r == -1) cout << r << "\n";
            else cout << arr[r] << "\n";
        }
    }

    cout << r + 1 << "\n";
    for (int i = 0; i <= r; i++) cout << arr[i] << " ";

    return 0;
}
```

## 3. 올바른 괄호열 (01:02:57)

매우 유명한 스택 활용 문제이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, arr[1010101];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    string S;
    cin >> S;
    int n = S.length();
    for (int i = 1; i <= n; i++) {
        char c = S[i - 1];
        if (c == '(') arr[i] = 0;
        if (c == ')') arr[i] = 1;
        if (c == '[') arr[i] = 2;
        if (c == ']') arr[i] = 3;
    }

    stack<int> s;
    for (int i = 1; i <= n; i++) {
        if (arr[i] % 2 == 0) s.push(arr[i]);
        if (arr[i] % 2 == 1) {
            if (s.top()/2 != arr[i]/2) {
                cout << "NO\n";
                return 0;
            }
            if (s.top()/2 == arr[i]/2) {
                s.pop();
            }
        }
    }

    if (s.size() == 0) cout << "YES\n";
    else cout << "NO\n";

    return 0;
}
```

## 4. 큐 (01:07:55)

`p, q` 두개의 포인터로 큐를 구현할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int arr[303030];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;
    int p = 0, q = -1;
    while (n--) {
        string s;
        cin >> s;
        if (s == "PUSH") {
            int x;
            cin >> x;
            arr[++q] = x;
        }
        if (s == "POP") {
            if (p > q) cout << "-1\n";
            else {
                cout << arr[p] << "\n";
                p++;
            }
        }
        if (s == "FRONT") {
            if (p > q) cout << "-1\n";
            else cout << arr[p] << "\n";
        }
        if (s == "BACK") {
            if (p > q) cout << "-1\n";
            else cout << arr[q] << "\n";
        }
    }

    cout << q - p + 1 << "\n";
    for (int i = p; i <= q; i++) cout << arr[i] << " ";

    return 0;
}
```

## 5. 하노이의 탑 (01:15:55)

재귀함수로 구현할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int arr[303030];
 
void solve(int cnt, int from, int to) {
    if (cnt == 0) return;
    int other = 6 - from - to;
    solve(cnt - 1, from, other);
    cout << from << " " << to << "\n";
    solve(cnt - 1, other, to);
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
 
    solve(n, 1, 3);
 
    return 0;
}
```

## 6. 부분 배열 최솟값 (02:07:04)

앞에서부터 차례대로 구한다고 생각해보자. 그러면 $k$번째 수보다 앞에 있고 $k$번째 수보다 큰 수는 더 이상 고려할 필요가 없음을 알 수 있다. 이를 이용하면 비교 횟수를 $O(n)$까지 줄일 수 있다. 구체적으로, 어떤 수가 추가될 때 한 번 비교되고, 제거될 때 한 번 비교되므로 $2n$번의 비교로 문제를 해결할 수 있다.

이를 `monotone queue` 기법이라고 한다. 함수 구현 문제임에 유의하자.

```cpp
#include "subarraymin.h"
#include <bits/stdc++.h>
using namespace std;
deque<int> dq;

void subarray_min(int n, int k) {
    for (int i = 1; i < k; i++) {
        while (dq.size() > 0) {
            if (compare(i, dq.back())) dq.pop_back();
            else break;
        }
        dq.push_back(i);
    }
    for (int i = k; i <= n; i++) {
        while (dq.size() > 0) {
            if (compare(i, dq.back())) dq.pop_back();
            else break;
        }
        dq.push_back(i);
        while (dq.size() > 0) {
            if (dq.front() < i - k + 1) dq.pop_front();
            else break;
        }
        answer(i - k + 1, dq.front());
    }
    dq.clear();
}
```

## 1. 메모장 (02:25:40)

연결 리스트를 잘 구현해보자! 가장 앞 커서를 나타내기 위해 더미 노드가 하나 필요하다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
 
struct Node {
    char c;
    Node *lt;
    Node *rt;
    Node() {
        c = '0';
        lt = NULL;
        rt = NULL;
    }
};
Node *cus = new Node();
 
Node* add(Node *prev, Node *now) {
    Node *next = prev->rt;
    now->rt = prev->rt;
    now->lt = prev;
    prev->rt = now;
    if (next != NULL) next->lt = now;
    return now;
}
 
Node* rem(Node *tar) {
    Node *next = tar->rt;
    Node *prev = tar->lt;
    if (next != NULL) next->lt = prev;
    if (prev != NULL) prev->rt = next;
    free(tar);
    return prev;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
 
    while (n--) {
        int t;
        cin >> t;
        if (t == 1) if (cus->lt != NULL) cus = cus->lt;
        if (t == 2) if (cus->rt != NULL) cus = cus->rt;
        if (t == 3) {
            char c;
            Node *now = new Node();
            cin >> c;
            now->c = c;
            cus = add(cus, now);
        }
        if (t == 4) {
            if (cus->lt == NULL) continue;
            cus = rem(cus);
        }
    }
 
    while (cus->lt != NULL) cus = cus->lt;
 
    cus = cus->rt;
    for (; cus != NULL; cus = cus->rt) {
        cout << cus->c;
    }
 
    return 0;
}
```

## 7. 집 짓기 (03:43:51)

$(a, b)$를 오른쪽 아래 꼭짓점으로 하는 가능한 터의 개수 $T_{a, b}$를 세는 방법을 생각해보자. 일단 왼쪽 위 꼭짓점 $(x, y)$에 대해 $x=a$인 $(x, y)$의 개수는 쉽게 찾을 수 있다. 이 값을 $S_{a, b}$라고 하면 $h_{a, b} = h_{a, b-1}$인 경우 $S_{a, b}=S_{a, b -1}+1$이고, $h_{a, b} ≠ h_{a, b-1}$인 경우 $S_{a,b}=1$이기 때문이다.

이제 이 $S_{a, b}$를 이용해 $T_{a, b}$를 구해보자. 우리는 이미 터의 높이가 $1$일 때 가능한 개수를 알고 있으므로, 이를 터의 높이가 $1$보다 클 때로 확장시켜야 한다. 즉, 일반적으로 $x=i<a$인 경우에 대해 살펴보겠다.

$(i, b-k+1)$와 $(a, b)$의 영역이 터가 된다는 것과 $i≤j≤a$인 모든 $i$에 대해 $S_{j, b}≥k$가 성립한다는 것은 필요충분조건이다. 즉, 우리는 각 $i≤a$에 대해 $\min_{i≤j≤a} S_{j, b}$의 값을 구하면 그 값이 $k$의 값으로 가능한 최댓값이므로, 그 값이 왼쪽 위 꼭짓점이 $(i, y)$일 때 가능한 터의 개수라고 할 수 있다. 즉, $T_{a, b}$는 아래와 같이 구할 수 있다.

$$
T_{a, b}=\sum_{i=1}^a {\min_{i \leq j \leq a} S_{j, b}}
$$

이제 $T_{a, b}$을 빠르게 구해보자. 만약 naive하게 구한다면 $O(N^2M^2)$의 시간복잡도를 가질 것이고, 당연히 시간 초과를 받을 것이다. 여기서 해야 하는 중요한 관찰은 $\min_{i≤j≤a} S_{j, b}$은 $i$가 감소함에 따라 감소하는 값이라는 것이다. 즉, 이 값들을 관리하는 deque를 만들면 `monotone deque`를 이용하여 쉽게 처리할 수 있다. 구체적으로, $S_{a, b}$가 추가되었을 때 이전 값인 $T_{a-1, b}$와의 차이를 계산하면 되고, 이 차이는 $S_{a, b}$보다 큰 수가 deque에 포함되어 있을 경우와 그렇지 않을 경우로 나누어서 파악하면 된다. 만약 $S_{a, b}$보다 큰 수가 deque에 포함되어 있으면 그 수 모두 $S_{a, b}$로 바뀌므로, 그 과정을 deque에 적용하면 된다.

여기서 주의할 점은 deque에는 중복된 수를 정확히 하나만 보관하고, 개수를 저장하는 배열을 따로 만들어야 한다는 점이다. 만약 그렇지 않으면 $S_{a, b}$가 $a$가 증가하며 계속 감소하는 최악의 경우 $O(N^2)$번 deque에서 값을 빼고 추가하는 연산이 일어나기 때문이다.

이렇게 구현할 경우 $O(1)$의 시간에 $T_{a, b}$를 구할 수 있고, 전체 $O(NM)$의 시간복잡도에 문제를 해결할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m, arr[1010][1010];
ll dp[1010][1010], res[1010][1010], ans = 0, temp[1010][1010];
ll cnt[1010];
deque<int> dq;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> arr[i][j];
 
    for (int i = 1; i <= n; i++) {
        dp[i][1] = 1;
        for (int j = 2; j <= m; j++) {
            dp[i][j] = 1;
            if (arr[i][j] == arr[i][j - 1]) dp[i][j] += dp[i][j - 1];
        }
    }
 
    for (int j = 1; j <= m; j++) {
        int p = 1; ll sum = 0;
        dq.clear();
        for (int i = 1; i <= m; i++) cnt[i] = 0;
        for (int i = 1; i <= n; i++) {
            if (arr[p][j] != arr[i][j]) {
                while (p < i) {
                    cnt[dp[p][j]] = 0;
                    p++;
                }
                dq.clear();
                sum = 0;
            }
 
            if (dq.size() == 0) {
                cnt[dp[i][j]] += 1;
                sum = sum + dp[i][j];
                res[i][j] = sum;
                dq.push_front(dp[i][j]);
                continue;
            }
 
            if (dq.front() <= dp[i][j]) {
                cnt[dp[i][j]] += 1;
                sum = sum + dp[i][j];
                res[i][j] = sum;
                if (dq.front() != dp[i][j]) dq.push_front(dp[i][j]);
                continue;
            }
            while (dq.size() > 0 && dq.front() > dp[i][j]) {
                sum = sum - cnt[dq.front()] * (dq.front() - dp[i][j]);
                cnt[dp[i][j]] += cnt[dq.front()];
                cnt[dq.front()] = 0;
                dq.pop_front();
            }
            dq.push_front(dp[i][j]);
            cnt[dp[i][j]] += 1;
            sum += dp[i][j];
            res[i][j] = sum;
        }
    }
 
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            ans += res[i][j];
        }
    }
 
    cout << ans << "\n";
 
    return 0;
}
```