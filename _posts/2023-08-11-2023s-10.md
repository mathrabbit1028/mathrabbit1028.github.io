---
title: 2023학년도 정보올림피아드 여름학교 10일차
author: mathrabbit
date: 2023-08-11 12:00:00 +0900
categories: [Problem Solving, 2023 여름학교]
tags: [camp]
math: true
---

2024-08-11 : 2024s-10 [동적계획법]

[문제지](https://drive.google.com/drive/folders/1FMgLZWZ5_FDtVo7MLEcnOsHiQjb4YRtr?usp=sharing)

## 1. 최대 부분합 (00:06:29)

$dp[i]$를 $i$번째 원소가 포함될 때 최대 부분합이라고 하자. 그러면 $dp[i] = max(dp[i - 1], 0) + arr[i]$로 계산할 수 있다. 시간복잡도는 $O(N)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int t, n, arr[1010101], dp[1010101];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> t;
    while (t--) {
        cin >> n;
        for (int i = 1; i <= n; i++) cin >> arr[i];
        for (int i = 0; i <= n; i++) dp[i] = 0;
        for (int i = 1; i <= n; i++) dp[i] = max(dp[i - 1], 0) + arr[i];
        int ans = 0;
        for (int i = 0; i <= n; i++) ans = max(ans, dp[i]);
        cout << ans << "\n";
    }
 
    return 0;
}
```

## 2. 계단 오르기 (00:09:50)

$dp[i]$를 $i$번 계단까지 오르는 경우의 수라 하면 점화식 $dp[i]=dp[i-1]+dp[i-2]+dp[i-3]$이 성립한다. 초깃값은 예제를 참고하자. 시간복잡도는 $O(N)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, arr[1010101], dp[1010101];
int MOD = 1e9 + 7;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        if (i >= 3) dp[i] = (dp[i] + dp[i - 3]) % MOD;
        if (i >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;
        if (i >= 1) dp[i] = (dp[i] + dp[i - 1]) % MOD;
    }
 
    cout << dp[n] << "\n";
 
    return 0;
}
```

## 3. 최장 공통 부분열 (00:19:21)

$dp[i][j]$를 첫 번째 문자열의 $i$번째 문자까지, 그리고 두 번째 문자열의 $j$번째 문자까지 보았을 때 LCS의 길이로 정의하자. 아래 점화식이 성립함을 확인할 수 있다.

- 만약 $i$번째 문자와 $j$번째 문자가 동일하면 $dp[i][j] = dp[i - 1][j - 1] + 1$
- 동일하지 않으면 $dp[i][j] = \max(dp[i - 1][j], dp[i][j - 1])$

역추적은 세 가지 상태 중 어디로부터 전이되었는지 기록하면 구해낼 수 있다. 시간복잡도는 $O(NM)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
string a, b;
int dp[4040][4040], path[4040][4040];
vector<char> LCS;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> a >> b;
    int n = a.length(), m = b.length();
 
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i - 1] == b[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                path[i][j] = -1;
            }
            else {
                if (dp[i][j - 1] < dp[i - 1][j]) path[i][j] = 0;
                else path[i][j] = 1;
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
 
    cout << dp[n][m] << "\n";
 
    int p = n, q = m;
    while (true) {
        if (p == 0 || q == 0) break;
        if (path[p][q] == -1) {
            LCS.push_back(a[p - 1]);
            p--; q--;
        }
        else if (path[p][q] == 0) p--;
        else q--;
    }
 
    reverse(LCS.begin(), LCS.end());
    for (int i = 0; i < LCS.size(); i++) cout << LCS[i];
 
    return 0;
}
```

## 4. 최장 증가 부분 수열 (00:32:31)

$dp[i]$를 $i$번째 문자를 끝으로 하는 최장 증가 부분 수열의 길이라고 하자. 그러면 $dp[i]$는 이전까지의 LIS를 저장한 백터에서 이분탐색으로 가장 최대한 멀리 갈 수 있는 위치를 찾아 그 자리에 삽입하는 것을 반복함으로써 구할 수 있다. 또한 그 자리가 $dp[i]$의 값이 된다.

역추적은, 각 $i$마다 삽입된 위치 앞에 위치한 수를 기록하면 계속 반복함으로써 구해낼 수 있다. 시간복잡도는 $O(N \log N)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, arr[1010101], path[1010101];
vector< pair<int, int> > vals;
vector<int> ans;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> arr[i];
 
    for (int i = 1; i <= n; i++) {
        int idx = lower_bound(vals.begin(), vals.end(), make_pair(arr[i], 0)) - vals.begin();
        path[i] = (idx == 0 ? 0 : vals[idx - 1].second);
        if (idx == vals.size()) vals.push_back({arr[i], i});
        else vals[idx] = {arr[i], i};
    }
 
    cout << vals.size() << "\n";
    int p = vals.back().second;
 
    while (p > 0) {
        ans.push_back(p);
        p = path[p];
    }
 
    reverse(ans.begin(), ans.end());
 
    for (int i = 0; i < ans.size(); i++) cout << ans[i] << " ";
 
    return 0;
}
```

## 5. 행렬곱 (00:56:26)

$dp[i][j]$를 $a_i$부터 $a_j$까지의 수들에 의한 행렬곱 결과라고 하자. 그러면 $i<k<j$인 모든 $k$에 대해

$$
dp[i][j] = \min_{i<k<j} {dp[i][k]+dp[k][j]+a_ia_ka_j}
$$

로 구할 수 있다. 시간복잡도는 $O(N^3)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
ll dp[505][505], arr[505];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n+1; i++) cin >> arr[i];
 
    for (int d = 2; d <= n; d++) {
        for (int i = 1; i <= n + 1 - d; i++) {
            int j = i + d;
            ll val = 1e18;
            for (int k = i + 1; k <= j - 1; k++) {
                val = min(val, dp[i][k] + dp[k][j] + arr[i] * arr[j] * arr[k]);
            }
            dp[i][j] = val;
        }
    }
 
    cout << dp[1][n+1] << "\n";
 
    return 0;
}
```

## 6. 괄호 ㄴㄴ 문자열 (02:02:16)

$dp[n][k]$를 길이가 $n$이고 앞에 열린 괄호의 개수가 $k$개인 올바른 괄호 문자열의 개수로 정의하자. 그러면 $k>0$에서 다음과 같은 점화식을 얻을 수 있다.

$$
dp[n][k] = \sum_{i=k+1}^n dp[i-k-1][0] \times dp[n-i+k-1][k-1]
$$

또한, 정의상 $dp[n][0] = dp[n][1]$임이 보장된다. 따라서 이렇게 모두 구한 이후에 아래 과정을 따라 사전순으로 $K$번째 오는 문자열을 찾자.

- 첫 번째 자리가 `(`인 문자열의 개수와 $K$를 비교한다.
    - $K$가 더 작으면 첫 번째 자리는 `(`이다.
    - 그렇지 않으면 첫 번째 자리는 `)`이다. $K$에서 개수만큼 빼서 남은 값을 저장하자.
- 이제 두 번째 자리가 `(`인 문자열의 개수를 $K$와 비교하면 같은 방식으로 해결할 수 있다. 이를 반복한다.

구현의 편의성을 위해 닫힌 문자열의 개수가 더 많아지면 항상 불가능함을 이용해 중간에 끊는 방법도 있다.

시간복잡도는 $O(N^2 + \log K)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll N, K, dp[55][55];
int ans[55];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> N >> K;
    dp[0][0] = 1;
    for (int n = 1; n <= N; n++) {
        for (int k = 1; k <= n; k++) {
            for (int i = k + 1; i <= n; i++) {
                dp[n][k] += dp[i - k - 1][0] * dp[n - i + k - 1][k - 1];
            }
        }
        dp[n][0] = dp[n][1];
    }
 
    if (K >= (1LL<<N) - dp[N][0]) {
        cout << "-1\n";
        return 0;
    }
    int r = 0, n = N, k = 0;
    while (K > 0) {
        if (k < 0) {
            if (K >= (1LL<<(N-r-1))) {
                K -= 1LL<<(N-r-1);
                ans[r++] = 1;
            }
            else ans[r++] = 0;
            continue;
        }
        if (K >= (1LL<<(n-k-1)) - dp[n][k+1]) {
            K -= (1LL<<(n-k-1)) - dp[n][k+1];
            ans[r++] = 1;
            k--;
            n -= 2;
        }
        else {
            ans[r++] = 0;
            k++;
        }
    }
 
    for (int i = 0; i < N; i++) {
        if (ans[i] == 0) cout << "(";
        else cout << ")";
    }
 
    return 0;
}
```

## 7. Bitonic Tour (02:36:34)

문제 조건을 잘 해석하면 $2$번부터 $N-1$번 정점까지를 두 그룹으로 나눈 후 $1$번과 $N$번 정점을 포함해 $x$좌표가 증가하는 순서대로 이었을 때 길이의 최솟값을 구하라는 문제와 동치임을 알 수 있다. 따라서 첫 번째 그룹의 가장 오른쪽 점이 $i$이고, 두 번째 그룹의 가장 오른쪽 점이 $j$일 때 최소 길이를 $dp[i][j]$라고 하자. 대칭적으로 $i>j$로 가정하자. 그러면 아래와 같은 점화관계를 얻을 수 있다.

$$
dp[i][j]=\begin{cases} dp[i-1][j]+\textrm{dis}(i, i-1) &\quad j < i-1 \\ \min_{1 \leq k \leq j} dp[j][k]+\textrm{dis}(i, k) &\quad j=i-1\end{cases} 
$$

시간복잡도는 $O(N^2)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
int n;
pii pos[1010];
double dp[1010][1010];
 
double dis(pii p, pii q) {
    return sqrt(pow(p.first - q.first, 2) + pow(p.second - q.second, 2));
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> pos[i].first >> pos[i].second;
    }
 
    for (int i = 2; i <= n; i++) dp[i][1] = dis(pos[i], pos[1]);
    for (int i = 3; i <= n; i++) {
        for (int j = 1; j < i - 1; j++) {
            dp[i][j] = dp[i - 1][j] + dis(pos[i - 1], pos[i]);
        }
        double val = 1e18;
        for (int k = 1; k < i - 1; k++)
            val = min(val, dp[i - 1][k] + dis(pos[k], pos[i]));
        dp[i][i - 1] = val;
        //for (int j = 1; j < i; j++) cout << dp[i][j] << " ";
        //cout << "\n";
    }
 
    double ans = 1e18;
    for (int j = 1; j < n; j++) ans = min(ans, dp[n][j] + dis(pos[j], pos[n]));
    printf("%.10f", ans);
 
    return 0;
}
```

## 10. Distribute Candies (04:53:41)

주어진 관계를 $i→a_i$를 이은 `functional graph`로 생각할 수 있다. 즉, 각 컴포넌트마다 사이클 개수는 정확히 하나임이 보장된다. 이렇게 그래프를 그리면 인접한 정점에 해당하는 두 사탕은 같은 통에 들어갈 수 없으므로 주어진 그래프를 $m$개의 색으로 컬러링하는 `$m$-coloring` 문제와 동치이다. 이제 사이클에 속하는 부분과 속하지 않는 부분으로 나누어 구하자.

- 속하는 부분: 사이클의 길이가 $c$일 때, 원판을 $c$개의 부채꼴로 나누고 인접한 부채꼴이 다른 색을 띄도록 $m$개의 색으로 색칠하는 문제와 동치이다. $f(c, m) = (m-2)f(c-1, m) + (m-1)f(c-2, m)$이 성립함이 잘 알려져 있다.
- 속하지 않는 부분: 항상 사이클쪽의 정점 하나와 연결되므로 $m-1$가지의 경우의 수가 있다.

따라서 각 컴포넌트의 사이클 길이를 구하고 $f(c, m)$을 전처리하면 답을 구할 수 있다. 각 컴포넌트의 사이클 길이는 `DFS`를 이용하거나 $v$에서 시작하는 간선이 하나임을 이용해 $v$에서 따라가면서 방문한 정점이 나올 때까지 이동해 찾을수도 있다. 시간복잡도는 $O(N)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
 
const ll MOD = 1e9 + 7;
ll n, m, dp[1010101];
 
int arr[1010101], ch[1010101], tot = 0;
vector<int> path;
int find_cycle(int v) {
    path.clear();
    while (ch[v] == 0) {
        ch[v] = 1;
        path.push_back(v);
        v = arr[v];
    }
    for (int i = 0; i < path.size(); i++) {
        if (v == path[i]) return path.size() - i;
    }
    return 0;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }
 
    dp[0] = 1;
    dp[1] = m;
    dp[2] = (m * (m - 1)) % MOD;
    dp[3] = (m * (m - 1) * (m - 2)) % MOD;
    for (int i = 4; i <= n; i++) {
        dp[i] = (dp[i] + dp[i - 1] * (m - 2)) % MOD;
        dp[i] = (dp[i] + dp[i - 2] * (m - 1)) % MOD;
    }
 
    ll ans = 1;
    for (int i = 1; i <= n; i++) {
        if (ch[i] == 0) {
            int c = find_cycle(i);
            tot += c;
            ans = (ans * dp[c]) % MOD;
            //cout << c << "\n";
        }
    }
 
    for (int i = tot + 1; i <= n; i++) ans = (ans * (m-1)) % MOD;
    cout << ans << "\n";
 
    return 0;
}
```

## 8. 마스크

(https://www.acmicpc.net/problem/16026)

성능이 감소하도록 정렬

$i$번째까지, $j$개를 판매했을 때 수익 $dp[i][j]$ → 냅색

메모리 절약을 위해 2개만 만들자 (토글링)

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

int n, m;
struct mask {
    int cnt, eff;
    ll cost;
} arr[4040];
bool compare(mask x, mask y) {
    if (x.eff == y.eff) return x.cnt > y.cnt;
    return x.eff > y.eff;
}

ll dp[2][101010];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> arr[i].cnt >> arr[i].eff >> arr[i].cost;
        arr[i].cost *= -1;
    }
    cin >> m;
    for (int i = n + 1; i <= n + m; i++) {
        cin >> arr[i].cnt >> arr[i].eff >> arr[i].cost;
        arr[i].cnt *= -1;
    }

    sort(arr + 1, arr + n + m + 1, compare);

    for (int j = 0; j <= 100000; j++) dp[0][j] = -1e18;
    dp[0][0] = 0;
    for (int i = 1; i <= n + m; i++) {
        for (int j = 0; j <= 100000; j++) dp[1][j] = -1e18;
        for (int j = 0; j <= 100000; j++) {
            dp[1][j] = max(dp[0][j], dp[1][j]);
            if (j + arr[i].cnt >= 0)
                dp[1][j + arr[i].cnt] = max(dp[1][j + arr[i].cnt], dp[0][j] + arr[i].cost);
        }
        for (int j = 0; j <= 100000; j++) dp[0][j] = dp[1][j];
    }

    ll ans = 0;
    for (int j = 0; j <= 100000; j++) ans = max(ans, dp[0][j]);
    cout << ans << "\n";

    return 0;
}
```

## 9. 최장 공통 부분열2

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/760d9c2c-c946-4455-bb70-07001c0bb305/Untitled.png)

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

int t, dp[4040][4040];
char path[4040][4040];
string a, b;
vector<int> idx[26];
vector<char> LCS;

int next(int st, char tar) {
    int t = tar - 'a';
    int ret = upper_bound(idx[t].begin(), idx[t].end(), st) - idx[t].begin();
    return (ret < idx[t].size() ? idx[t][ret] : 1e9);
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> t;
    while (t--) {
        cin >> a >> b;
        int n = a.length(), m = b.length();
        for (int i = 0; i <= m; i++) for (int j = 0; j <= m; j++) dp[i][j] = 1e9;
        for (int i = 0; i <= m; i++) for (int j = 0; j <= m; j++) path[i][j] = '0';
        LCS.clear();
        for (int i = 0; i < 26; i++) idx[i].clear();
        for (int i = 0; i < n; i++) idx[a[i] - 'a'].push_back(i);

        dp[0][0] = -1;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i; j++) {
                if (dp[i + 1][j] > dp[i][j]) {
                    dp[i + 1][j] = dp[i][j];
                    path[i + 1][j] = '0';
                }
                if (dp[i + 1][j + 1] > next(dp[i][j], b[i])) {
                    dp[i + 1][j + 1] = next(dp[i][j], b[i]);
                    path[i + 1][j + 1] = b[i];
                }
            }
        }

        int ans;
        for (int j = m; j >= 0; j--) {
            if (dp[m][j] < 1e9) {
                ans = j;
                break;
            }
        }
        cout << ans << "\n";
        int p = m, q = ans;
        while (q > 0) {
            if (path[p][q] == '0') p--;
            else {
                LCS.push_back(path[p][q]);
                p--; q--;
            }
        }
        reverse(LCS.begin(), LCS.end());
        for (int i = 0; i < LCS.size(); i++) cout << LCS[i];
        if (LCS.size() > 0) cout << "\n";
    }

    return 0;
}
```

## 11. Fountain Parks

총 $D-1$번동안 각 정점을 방문하는 횟수를 세자. $(i, j)$를 방문하는 횟수 $k$가 짝수이면 각 정점에 인접한 정점을 $k/2$번씩 방문하게 될 것이고, 홀수이면 처음 화살표가 있는 곳은 $k/2+1$번, 나머지는 $k/2$번 방문하게 될 것이다. 따라서 $O(NM)$에 방문 횟수를 구할 수 있고 $O(N+M)$에 한번 시뮬레이션하여 결과를 얻을 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

int n, m, d, arr[1010][1010], cnt[1010][1010];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n >> m >> d;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> arr[i][j];
        }
    }

    cnt[1][1] = d - 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cnt[i + 1][j] += cnt[i][j]/2;
            cnt[i][j + 1] += cnt[i][j]/2;
            if (arr[i][j] == 0) cnt[i + 1][j] += cnt[i][j] % 2;
            if (arr[i][j] == 1) cnt[i][j + 1] += cnt[i][j] % 2;
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            arr[i][j] = (arr[i][j] + cnt[i][j]) % 2;
        }
    }

    int p = 1, q = 1;
    while (p <= n && q <= m) {
        if (arr[p][q] == 0) p++;
        else q++;
    }

    cout << p << " " << q << "\n";

    return 0;
}
```

## 12. Dungeons game

2개의 반직선만 있어도 막을 수 있다?????

## 13. 미술 시간

관찰 1. 무조건 $N$개의 수를 다 쓰는 것이 이득이다.

문제를 플러스와 마이너스를 나열하는 것으로 환원할 수 있다???

$dp[n][k][x]$: $1$부터 $n$까지의 수를 $k$개의 그룹으로 나눴을 때 현재까지 쓴 (더하기 개수 - 빼기 개수)가 $x$일 때 가능한 최댓값 ($x=-1, 0, 1$ 중 하나)

하나의 구간에는 플러스 

(?? 모르겠음)