---
title: 2023학년도 정보올림피아드 여름학교 4일차
author: mathrabbit
date: 2023-08-05 12:00:00 +0900
categories: [Problem Solving, 2023 여름학교]
tags: [camp]
math: true
---

2024-08-05 : 2024s-04 [STL]

[문제지](https://drive.google.com/drive/folders/1I0vbbD6lt_yLpTTpzzcIbWspOHYrpw3A?usp=sharing)

## 1. 순열 (00:05:15)

`std::next_permutation()`과 `std::prev_permutation()`을 사용하라는 문제다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, arr[1010101];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 0; i < n; i++) cin >> arr[i];
    prev_permutation(arr, arr + n);
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
    cout << "\n";
    next_permutation(arr, arr + n);
    next_permutation(arr, arr + n);
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
    cout << "\n";
 
    return 0;
}
```

## 2. 바구니 (00:18:14)

`std::map`으로 각 값을 key로, 개수를 value로 하는 문제이다. `std::multiset`을 사용해도 된다고 생각할 수 있으나, `std::multiset`의 경우 `count()` 함수의 시간복잡도가 개수에 비례하기 때문에 최악의 경우 $O(Q^2)$의 시간복잡도를 갖는다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int q;
map<int, int> m;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> q;
    while (q--) {
        int t;
        cin >> t;
        if (t == 1) {
            int a;
            cin >> a;
            if (m.find(a) == m.end()) m.insert({a, 1});
            else {
                int val = m.find(a)->second;
                m.erase(a);
                m.insert({a, val + 1});
            }
        }
        if (t == 2) {
            int a;
            cin >> a;
            if (m.find(a) != m.end()) {
                int val = m.find(a)->second;
                m.erase(a);
                if (val > 1) m.insert({a, val - 1});
            }
        }
        if (t == 3) {
            int a;
            cin >> a;
            cout << m.find(a)->second << "\n";
        }
    }
 
    return 0;
}
```

## 3. 유니크 (00:20:35)

`std::unique`를 사용하여 중복 값을 제거하면 된다. 좌표압축을 위한 첫 단계이므로 알아두도록 하자.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
vector<int> arr;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int a;
        cin >> a;
        arr.push_back(a);
    }
 
    sort(arr.begin(), arr.end());
    arr.erase(unique(arr.begin(), arr.end()), arr.end());
 
    for (int i = 0; i < arr.size(); i++) cout << arr[i] << " ";
    cout << "\n";
 
    return 0;
}
```

## 4. 사과나무 (00:31:07)

주어진 사과나무를 나이순으로 정렬하자. 그리고 이분탐색으로 $[l_i, r_i]$에 속하는 사과나무들을 찾자. 사과나무의 개수는 구간의 길이이므로 인덱스 차이로, 총 사과의 개수는 구간합으로 구할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, q;
long long arr[505050], sum[505050];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> arr[i];
    sort(arr + 1, arr + n + 1);
    for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + arr[i];
 
    while (q--) {
        long long l, r;
        cin >> l >> r;
        long long st = lower_bound(arr + 1, arr + n + 1, l) - arr;
        long long ed = upper_bound(arr + 1, arr + n + 1, r) - arr;
        cout << max(0LL, ed - st) << " " << max(0LL, sum[ed - 1] - sum[st - 1]) << "\n";
    }
 
    return 0;
}
```

## 5. 실습 문제 준비 (00:45:13)

맡을 수 있는 문제 중 가능한 한 번호가 높은 문제를 맡는 것이 최적이다. 간단히 `set`을 이용해 구현할 수 있다.

물론, 위 말을 다르게 해석하면 $i$번째 수 $x$보다 앞에 있는 수 중 $i$번째 수 이하인 수의 개수가 $x$ 이상이면 불가능하다는 의미이기도 하므로, 세그먼트 트리로도 해결할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, arr[101010];
 
set<int> s;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= m; i++) cin >> arr[i];
 
    for (int i = 1; i <= n; i++) s.insert(-i);
    for (int i = 1; i <= m; i++) {
        auto iter = s.lower_bound(-arr[i]);
        if (iter == s.end()) {
            cout << i - 1 << "\n";
            return 0;
        }
        s.erase(iter);
    }
 
    cout << m << "\n";
 
    return 0;
}
```

## 6. 볼륨을 높여라! (02:38:07)

세 능력치를 $(x, y, z)$라고 놓으면, $(0, 0, 0)$과 $(x, y, z)$를 공간대각선으로 하는 모든 직육면체의 포함되는 부분의 넓이합을 구하는 문제로 환원된다. 이를 풀기 위해 한 $x$값에서 $yz$ 평면에 평행한 단면을 보자.

이 단면은 계단형 모양임이 보장되므로, 이 계단형 모양의 꼭짓점 $(y, z)$만 저장해도 충분히 계단형 모양을 나타낼 수 있다. 구체적으로 저장된 꼭짓점을 $(y_1, z_1), (y_2, z_2), \cdots, (y_m, z_m)$ ($y_1 ≤ y_2 ≤ \cdots ≤ y_m$**)**이라고 하면, $z_1≥z_2≥\cdots≥z_m$을 만족하며, $y_{i-1}≤y≤y_i$의 $z$ 값은 $z_i$라는 의미를 갖는다. 여기서 $y_0=0$이다.

이제 새로운 $(y, z)$가 추가되는 상황을 생각해보자. 만약 기존의 영역에 포함된다면 무시하면 된다. 그렇지 않고 남는 부분이 있다면 수식적으로 $(y, z)$에 의한 변화를 계산하여야 한다. 구체적으로, $y$부터 $y$의 값이 감소하는 방향으로 가면서 따지는데, 만약 $z_k≥z$인 꼭짓점 $(y_k, z_k)$에 도달하면 멈추면 되며, 그 사이에 늘어나는 양은 $z_i - z$에 $y$ 폭의 길이를 곱해 구할 수 있다. 또한, $y_i≤y, z_i≤z$인 $(y_i, z_i)$는 더 이상 꼭짓점 역할을 하지 못하므로 제거한다.

즉, 순서쌍의 추가, 제거가 일어날 때 정렬된 상태로 유지해야 하므로 `std::set`을 사용하는 것이 적절하며, 한 번 늘어나는 면적을 계산할 때마다 set에 있는 좌표가 하나씩 줄어들기 때문에 면적 계산 횟수는 $O(n)$임이 보장된다. 따라서 시간복잡도 $O(n \log n)$에 문제를 해결할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
 
int n;
struct threeD {
    ll x, y, z;
} arr[202020];
 
bool compare(threeD p, threeD q) {
    return p.x > q.x;
}
 
set< pair<ll, ll> > pset, mset;
vector< pair<ll, ll> > rem;
ll ans = 0, sum = 0;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> arr[i].x >> arr[i].y >> arr[i].z;
    sort(arr + 1, arr + n + 1, compare);
 
    for (int i = 1; i <= n; i++) {
        auto next = pset.lower_bound({arr[i].y, 0});
        if (next != pset.end() && next->second >= arr[i].z) {
            ans += sum * (arr[i].x - arr[i + 1].x);
            continue;
        }
 
        rem.clear();
        auto prev = mset.lower_bound({-arr[i].y, 0});
        ll left = -arr[i].y, down = (next != pset.end() ? next->second : 0);
        for (auto iter = prev; iter != mset.end(); iter++) {
            sum += (arr[i].z - down) * (iter->first - left);
            left = iter->first;
            down = iter->second;
            if (iter->second >= arr[i].z) break;
            rem.push_back({-iter->first, iter->second});
        }
 
        if (down < arr[i].z) sum += (arr[i].z - down) * (0 - left);
 
        for (int j = 0; j < rem.size(); j++) {
            pset.erase({rem[j].first, rem[j].second});
            mset.erase({-rem[j].first, rem[j].second});
        }
        pset.insert({arr[i].y, arr[i].z});
        mset.insert({-arr[i].y, arr[i].z});
 
        ans += sum * (arr[i].x - arr[i + 1].x);
    }    
 
    cout << ans << "\n";
 
    return 0;
}
```

## 8. 두 절친 (04:21:22)

https://www.acmicpc.net/problem/16764

포함과 배제의 원리를 이용하자. 하나 이상이 일치하는 쌍부터 5개 모두가 일치하는 쌍까지 개수를 세면 된다. 이후, 각 종류마다의 개수 $c$를 구하여 $c(c-1)/2$를 빼면 쌍의 개수가 된다는 사실을 이용하면 답을 구할 수 있다.

구현의 편의를 위해 `std::vector` 객체를 이용하자. 이 객체는 놀랍게도 비교 연산이 정의되어 있기 때문에 `set`이나 `map`에서 자유롭게 사용할 수 있다. `map`을 사용해 `vector`을 key로 하고 값을 value로 하면 쉽게 구현할 수 있다. 이 과정은 2번 문제와 완전히 동일하다. 아래는 구현 코드이다.

```cpp
#include <bits/stdc++.h>
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
typedef long long ll;
 
ll n;
int arr[50505][5];
map< vector<int>, int > m[6];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
 
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < 5; j++) cin >> arr[i][j];
        sort(arr[i], arr[i] + 5);
    }
 
 
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j < 32; j++) {
            vector<int> t;
            for (int k = 0; k < 5; k++) {
                if (j & (1<<k)) t.push_back(arr[i][k]);
            }
            m[t.size()][t]++;
        }
    }
 
    ll ans = n * (n - 1) / 2;
    for (int c = 1; c <= 5; c++) {
        ll cof = -1;
        if (c % 2 == 0) cof = 1;
        for (auto iter = m[c].begin(); iter != m[c].end(); iter++) {
            ans += cof * iter->second * (iter->second - 1) / 2;
        }
    }
 
    cout << ans << "\n";
 
    return 0;
}
```

## 7. 슈퍼컴퓨터

CPU를 성능이 낮은 것부터 높은 순으로 정렬한다. 만약 성능이 똑같으면 전기세가 적은 것을 앞에 놓는다. 요구사항은 성능이 낮은 것부터 높은 순으로 정렬한다.

파라메트릭 서칭을 한다. 구체적으로 이득이 $a$원 이상이 될 때만 빌려준다는 것이다. 이제 우리는 각 CPU마다 가능한 요구들을 우선순위 큐에 넣어 가능한 많은 돈을 주는 요구와 그 CPU를 매칭시킨다. 그 개수가 $k$개보다 많다면 $a$를 줄이고, $k$보다 적다면 $a$를 늘린다.