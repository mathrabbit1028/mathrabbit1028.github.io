---
title: 2023학년도 정보올림피아드 여름학교 8일차
author: mathrabbit
date: 2023-08-09 12:00:00 +0900
categories: [Problem Solving, 2023 여름학교]
tags: [camp]
math: true
---

2024-08-09 : 2024s-08 [그래프]

[문제지](https://drive.google.com/drive/folders/1IPSiBYK4wIgQKWvIF2r0MiO9ipFXQ-pY?usp=sharing)

## 1. 인접 리스트 (00:05:54)

벡터를 사용해서 인접 리스트를 구현하면 된다. 인접행렬과 다르게 공간복잡도 $O(N)$이고, BFS, DFS 등의 탐색에서 시간복잡도 $O(N+M)$이 가능하게 해주는 자료 구조이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, t;
vector<int> adj[101010];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m >> t;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        adj[x].push_back(y);
        if (t) adj[y].push_back(x);
    }
 
    for (int i = 0; i < n; i++) {
        sort(adj[i].begin(), adj[i].end());
        cout << adj[i].size() << " ";
        for (int j = 0; j < adj[i].size(); j++) cout << adj[i][j] << " ";
        cout << "\n";
    }
 
    return 0;
}
```

## 2. 너비우선탐색 (00:08:25)

`queue`를 이용해 BFS를 짜자. 시간복잡도는 $O(N)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, ch[101010];
vector<int> adj[101010];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        adj[x].push_back(y);
        adj[y].push_back(x);
    }
 
    queue<int> q;
    for (int i = 1; i <= n; i++) ch[i] = 0;
    ch[1] = 1;
    q.push(1);
    while (!q.empty()) {
        int v = q.front();
        cout << v << " ";
        q.pop();
        for (int i = 0; i < adj[v].size(); i++) {
            if (ch[adj[v][i]] == 0) {
                ch[adj[v][i]] = 1;
                q.push(adj[v][i]);
            }
        }
    }
 
    return 0;
}
```

## 3. 깊이우선탐색 (00:09:42)

재귀적으로 DFS를 짜자. 시간복잡도는 $O(N)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, ch[101010];
vector<int> adj[101010];
 
void DFS(int v) {
    cout << v << " ";
    for (int i = 0; i < adj[v].size(); i++) {
        if (ch[adj[v][i]] == 1) continue;
        ch[adj[v][i]] = 1;
        DFS(adj[v][i]);
    }
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        adj[x].push_back(y);
        adj[y].push_back(x);
    }
 
    for (int i = 1; i <= n; i++) ch[i] = 0;
    ch[1] = 1;
    DFS(1);
 
    return 0;
}
```

## 4. 가장 짧은 사이클 (00:38:22)

유향그래프의 사이클 판별은 DFS로도 가능하지만, 무향그래프에서 가장 짧은 사이클을 찾는 것은 BFS로 해결해야 한다. 각 정점 $v$부터 시작해 BFS를 돌리는데, 이미 방문한 정점을 방문하는 경우 도달하는 두 가지 길에서의 이동거리 합에 1을 더한 것이 사이클의 길이가 된다. 즉, $v$에서 시작한 BFS로 $v$를 지나는 사이클 중 가장 길이가 짧은 사이클을 구할 수 있다.

이 과정에서 무향그래프이므로 같은 간선을 통해 사이클이 형성되는 경우를 제외하기 위해 부모 정점을 지나가는 경우는 무시하자. 이렇게 하면 $O(NM)$에 답을 구할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, ans = 1e9, ch[550], dis[550];
vector<int> adj[550];
queue< pair<int, int> > q;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        adj[x].push_back(y);
        adj[y].push_back(x);
    }
    for (int s = 1; s <= n; s++) {
        for (int i = 1; i <= n; i++) ch[i] = 0;
        ch[s] = 1;
        dis[s] = 0;
        q.push({s, 0});
        while (!q.empty()) {
            int v = q.front().first, prev = q.front().second;
            q.pop();
            for (int i = 0; i < adj[v].size(); i++) {
                int next = adj[v][i];
                if (next == prev) continue;
                if (ch[next] == 1) ans = min(ans, dis[v] + dis[next] + 1);
                else {
                    ch[next] = 1;
                    dis[next] = dis[v] + 1;
                    q.push({next, v});
                }
            }
        }
    }
 
    cout << ans << "\n";
 
    return 0;
}
```

## 5. 최소 신장 트리 (00:44:18)

프림 알고리즘 또는 크루스칼 알고리즘 중 하나를 골라 구현하면 된다. 아래는 크루스칼 알고리즘의 구현한 것으로, 시간복잡도는 $O(M \log M)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, root[101010];
vector< pair<int, pair<int, int> > > edges;
long long ans = 0;
 
int _find(int v) {
    if (v == root[v]) return v;
    else return root[v] = _find(root[v]);
}
 
bool _union(int v, int u) {
    v = _find(v);
    u = _find(u);
    if (v == u) return false;
    root[u] = v;
    return true;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        edges.push_back({c, {a, b}});
    }
 
    sort(edges.begin(), edges.end());
 
    for (int i = 1; i <= n; i++) root[i] = i;
 
    for (int i = 0; i < edges.size(); i++) {
        if (_union(edges[i].second.first, edges[i].second.second)) {
            ans += edges[i].first;
        }
    }
 
    cout << ans << "\n";
 
    return 0;
}
```

## 6. 국밥 (00:52:05)

$O(N \log N)$ 다익스트라 문제이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m, s;
vector< pair<int, long long> > adj[101010];
priority_queue< pair<long long, int> > pq;
long long dis[101010];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m >> s;
    for (int i = 1; i <= m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        adj[a].push_back({b, c});
    }
 
    for (int i = 1; i <= n; i++) dis[i] = 1e18;
    dis[s] = 0;
    pq.push({-dis[s], s});
 
    while (!pq.empty()) {
        int v = pq.top().second; ll d = -pq.top().first;
        pq.pop();
        if (d > dis[v]) continue;
        for (int i = 0; i < adj[v].size(); i++) {
            int next = adj[v][i].first; ll w = adj[v][i].second;
            if (dis[next] > d + w) {
                dis[next] = d + w;
                pq.push({-dis[next], next});
            }
        }
    }
 
    for (int i = 1; i <= n; i++) {
        if (dis[i] == 1e18) cout << "-1\n";
        else cout << dis[i] << "\n";
    }
 
    return 0;
}
```

## 7. 두 번째 최단 경로 (01:07:26)

두 번째 최단 경로를 찾는 방법은 다익스트라의 기본 원리에서 찾을 수 있다. 다익스트라는 동적계획법 기반이며, 이를 빠르게 처리하기 위해 힙 구조를 사용하는 것이므로, 매 정점마다 최단 거리만 저장하는 것이 아니라 두 번째 최단 경로의 길이도 저장한다. 그러면 이 두 개의 값을 쌍으로 보았을 때 일반적인 점화식을 만들어낼 수 있을 것이다. 이를 힙 구조를 이용해 빠르게 처리하면 된다.

구체적으로, 현재 거리가 어떤 정점의 두 번째 최단 경로보다 짧으면 갱신해야 한다. 만약 이 값이 최단 경로 길이와 같으면 업데이트 하지 않고, 그렇지 않으면 총 3가지 후보 중 가장 가까운 두 거리를 순서대로 최단 거리와 두 번째 최단 거리로 저장한다.

이렇게 하면 $O(N \log N)$의 시간에 맞을 수 있다. 구체적으로 $k$번째 최단 경로를 찾아야 하는 경우에는 $O(kN \log N)$의 시간에 답을 구할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m, s, t;
vector< pair<int, long long> > adj[101010];
priority_queue< pair<long long, int> > pq;
long long dis[101010], sdis[101010];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m >> s >> t;
    for (int i = 1; i <= m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        adj[a].push_back({b, c});
        adj[b].push_back({a, c});
    }
 
    for (int i = 1; i <= n; i++) dis[i] = 1e18;
    for (int i = 1; i <= n; i++) sdis[i] = 1e18;
    dis[s] = 0;
    pq.push({0, s});
 
    while (!pq.empty()) {
        int v = pq.top().second; ll d = -pq.top().first;
        //cout << "pq : " << v << " " << d << "\n";
        pq.pop();
        if (d > sdis[v]) continue;
        for (int i = 0; i < adj[v].size(); i++) {
            int next = adj[v][i].first; ll w = adj[v][i].second;
            if (sdis[next] > d + w) {
                if (d + w > dis[next]) sdis[next] = d + w;
                if (d + w < dis[next]) { sdis[next] = dis[next]; dis[next] = d + w; }
                pq.push({-(d + w), next});
            }
        }
    }
 
    //for (int i = 1; i <= n; i++) cout << dis[i] << " " << sdis[i] << "\n";
 
    cout << sdis[t] << "\n";
 
    return 0;
}
```

## 8. 사진 (01:17:43)

사전순으로 출력해야 하기 때문에, 위상정렬을 하되 번호가 작은 것에 우선순위를 두자. 큐를 이용해 구현할 때는 큐에 넣는 순서를 번호가 작은 것부터로 하면 되고, `set` 등의 자료구조를 이용해 구현할 때는 번호도 포함시켜 오름차순 정렬하면 된다. 아래는 `set`을 이용한 구현 코드이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m, in[101010];
vector<int> adj[101010];
set< pair<int, int> > s;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].push_back(b);
        in[b]++;
    }
 
    for (int i = 1; i <= n; i++) {
        s.insert({in[i], i});
    }
 
    for (int i = 1; i <= n; i++) {
        int v = s.begin()->second;
        cout << v << " ";
        s.erase(s.begin());
        for (int j = 0; j < adj[v].size(); j++) {
            int u = adj[v][j];
            if (s.find({in[u], u}) == s.end()) continue;
            s.erase({in[u], u});
            in[u]--;
            s.insert({in[u], u});
        }
    }
 
    return 0;
}
```

## 9. 단절점 (01:36:36)

루트가 아닌 정점 $v$에 대해 $v$를 방문하기 이전에 방문한 정점 $a$와 $v$를 방문한 이후 방문한 정점 $b$에 대해 $a$와 $b$가 연결된 순서쌍 $(a, b)$가 존재하면 $v$는 단절점이 아니다. 따라서 DFS를 돌면서 자신의 자식 노드들이 방문한 정점 중 가장 이르게 방문한 정점의 방문 순서를 리턴받아 비교하면 쉽게 단절점을 판별할 수 있다. 

루트 노드의 경우, 다음 `DFS(next)`의 호출 횟수가 $2$번 이상이면 단절점이고, 아니면 단절점이 아니다.

시간복잡도 $O(N+M)$에 문제를 해결할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m, ord[101010], ch[101010], iscut[101010];
vector<int> adj[101010];
 
int r = 0;
int solve(int v) {
    ord[v] = ++r;
    int fast = 1e9, child = 0;
 
    for (int i = 0; i < adj[v].size(); i++) {
        int u = adj[v][i];
        if (ch[u] == 1) fast = min(fast, ord[u]);
        else {
            child++;
            ch[u] = 1;
            int prev = solve(u);
            if (v != 1 && prev >= ord[v]) iscut[v] = 1;
            fast = min(fast, prev);
        }
    }
 
    if (v == 1 && child >= 2) iscut[v] = 1;
 
    return fast;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
 
    ch[1] = 1;
    solve(1);
 
    for (int i = 1; i <= n; i++) cout << iscut[i];
 
    return 0;
}
```

## 10. 단절선 (02:16:02)

어떤 간선 $e$에서 루트 쪽에 가까운 정점을 $v$라고 하자. 만약 $v$의 부모에서 오는 경로를 제외하고 $v$로 오는 경로 중, $v$보다 방문 순서가 이른 정점이 없으면 그 간선 $e$는 단절선이다. 단절점과 동일하게 가장 이르게 방문한 정점의 방문 순서를 리턴받아 비교하면 쉽게 단절선을 판별할 수 있다.

시간복잡도 $O(N+M)$에 문제를 해결할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m, ord[101010], ch[101010], iscut[202020];
vector< pair<int, int> > adj[101010];
 
int r = 0;
int solve(int v, int p) {
    ord[v] = ++r;
    int fast = 1e9;
 
    for (int i = 0; i < adj[v].size(); i++) {
        int u = adj[v][i].first, j = adj[v][i].second;
        if (u == p) continue;
        if (ch[u] == 1) fast = min(fast, ord[u]);
        else {
            ch[u] = 1;
            int prev = solve(u, v);
            if (prev > ord[v]) iscut[j] = 1;
            fast = min(fast, prev);
        }
    }
 
    return fast;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].push_back({b, i});
        adj[b].push_back({a, i});
    }
 
    ch[1] = 1;
    solve(1, 0);
 
    for (int i = 1; i <= m; i++) cout << iscut[i];
 
    return 0;
}
```

## 13. 탑 쌓기 (04:36:11)

백준의 [토르비욘 문제](https://www.acmicpc.net/problem/13361)와 동일하다.

주어진 문제를 잘 해석하면 각 $i$번째 판에 대해 $w_i$와 $h_i$ 중 하나를 골라 감소수열이 되고 그 합이 최소가 경우를 찾는 문제로 볼 수 있다. 이를 해결하기 위해 각 $w_i$ 및 $h_i$마다 인덱스 $i$를 저장하자. 이후 같은 값에 있는 두 인덱스 $i$와 $j$를 묶어 분리 집합을 만들면, 그 집합 안에 속한 인덱스의 판들의 양 변의 길이 중 작은 것들을 감소수열에 사용하자. 이 풀이가 정당화되는 이유는 분리 집합의 연결 상태에 상관 없이 탑을 쌓을 수 있다면 가장 작은 것을 $w_i$와 $h_i$가 모두 사용되지 않도록 고를 수 있기 때문이다.

만약 좌표압축을 하고싶지 않다면 $(w_i, i)$와 $(h_i, i)$를 모두 넣고 정렬한 뒤에 인접한 원소끼리만 순서쌍의 첫 번째 값을 비교하는 방법이 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
 
int n;
ll ans = 0;
pair<ll, ll> arr[252525];
vector<ll> com;
vector<int> idx[505050];
vector<int> group[252525];
 
int root[252525];
int _find(int v) {
    if (root[v] == v) return v;
    else return root[v] = _find(root[v]);
}
 
void _union(int v, int u) {
    v = _find(v);
    u = _find(u);
    if (v == u) return;
    root[v] = u;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> arr[i].first >> arr[i].second;
    for (int i = 1; i <= n; i++) {
        com.push_back(arr[i].first);
        com.push_back(arr[i].second);
        ans += arr[i].first;
        ans += arr[i].second;
        root[i] = i;
    }
    sort(com.begin(), com.end());
    com.erase(unique(com.begin(), com.end()), com.end());
    for (int i = 1; i <= n; i++) {
        arr[i].first = lower_bound(com.begin(), com.end(), arr[i].first) - com.begin();
        arr[i].second = lower_bound(com.begin(), com.end(), arr[i].second) - com.begin();
        idx[arr[i].first].push_back(i);
        idx[arr[i].second].push_back(i);
    }
 
    for (int i = 0; i < com.size(); i++) {
        for (int j = 1; j < idx[i].size(); j++) {
            _union(idx[i][j - 1], idx[i][j]);
        }
    }
 
    for (int i = 1; i <= n; i++) {
        group[_find(i)].push_back(i);
    }
 
    for (int i = 1; i <= n; i++) {
        vector<int> lens;
        for (int j = 0; j < group[i].size(); j++) {
            lens.push_back(arr[group[i][j]].first);
            lens.push_back(arr[group[i][j]].second);
        }
        sort(lens.begin(), lens.end());
        lens.erase(unique(lens.begin(), lens.end()), lens.end());
        for (int j = 0; j < group[i].size(); j++) {
            ans -= com[lens[j]];
        }
    }
 
    cout << ans << "\n";
 
}
```

## 11. 오늘 뭐 먹지?

DAG임이 보장되므로 $a_i→b_i$로 가는 정방향 그래프와 $b_i→a_i$로 가는 역방향 그래프를 이용해 위상정렬하여 각 음식에 대해 자신보다 무조건 선호도가 높은 음식의 개수와, 자신보다 무조건 선호도가 낮은 음식의 개수를 구한 뒤 주어진 조건에 맞추어 개수를 세면 된다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int x, y, n, m, in[5050], IN[5050], out[5050], OUT[5050];
vector<int> inadj[5050], outadj[5050];
queue<int> q;
 
int Tlsort(int t) {
    for (int i = 0; i < n; i++) in[i] = IN[i];
    while (!q.empty()) q.pop();
 
    for (int i = 0; i < n; i++) {
        if (i == t) continue;
        if (in[i] == 0) q.push(i);
    }
 
    int cnt = 1;
    while (!q.empty()) {
        int v = q.front(); 
        cnt++;
        q.pop();
        for (int i = 0; i < inadj[v].size(); i++) {
            int u = inadj[v][i];
            in[u]--;
            if (u == t) continue;
            if (in[u] == 0) q.push(u);
        }
    }
    return cnt;
}
 
int Tfsort(int t) {
    for (int i = 0; i < n; i++) out[i] = OUT[i];
    while (!q.empty()) q.pop();
 
    for (int i = 0; i < n; i++) {
        if (i == t) continue;
        if (out[i] == 0) q.push(i);
    }
 
    int cnt = 1;
    while (!q.empty()) {
        int v = q.front(); 
        cnt++;
        q.pop();
        for (int i = 0; i < outadj[v].size(); i++) {
            int u = outadj[v][i];
            out[u]--;
            if (u == t) continue;
            if (out[u] == 0) q.push(u);
        }
    }
    return cnt;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> x >> y >> n >> m;
    for (int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;
        inadj[a].push_back(b);
        outadj[b].push_back(a);
        IN[b]++;
        OUT[a]++;
    }
 
    int ans1 = 0, ans2 = 0, ans3 = 0;
    for (int i = 0; i < n; i++) {
        int last = Tlsort(i);
        int first = n + 1 - Tfsort(i);
        //cout << last << " " << first << "\n";
        if (last <= x) ans1++;
        if (last <= y) ans2++;
        if (first > y) ans3++;
    }
 
    cout << ans1 << "\n" << ans2 << "\n" << ans3 << "\n";
 
    return 0;
}
```

## 12. 그래프 그리기

어떤 양의 정수 $x~(0 \leq x <N)$에 대해 $x→x+1$과 $x→10x$ 간선을 연결하자. 그러면 모든 간선의 가중치가 $0$ 또는 $1$이 된다. 특히, 전자의 가중치는 $1$, 후자의 가중치는 $0$이다(전자의 경우에서 받아올림을 고려하지 않아도 되는 이유는 $x→10x$ 간선을 먼저 지남으로써 받아올림을 처리할 수 있기 때문이다). 이제 $1$을 시작으로 두고 `0-1 BFS`를 하자.

`0-1 BFS`는 가중치가 $0$인 간선을 통해 간 지점은 덱의 앞쪽에, 가중치가 $1$인 간선을 통해 간 지점은 덱의 뒤쪽에 넣고, 덱의 앞에서부터 값을 빼면 최단거리를 찾을 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, dis[1010101];
deque<int> dq;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;

    for (int i = 0; i < n; i++) dis[i] = 1e9;
    dis[1] = 1;
    dq.push_back(1);
    while (!dq.empty()) {
        int m = dq.front();
        dq.pop_front();
        if (dis[(10*m)%n] > dis[m]) {
            dis[(10*m)%n] = dis[m];
            dq.push_front((10*m)%n);
        }
        if (dis[(m+1)%n] > dis[m] + 1) {
            dis[(m+1)%n] = dis[m] + 1;
            dq.push_back((m+1)%n);
        }
    }

    cout << dis[0] << "\n";
    return 0;
}
```