---
title: 2023학년도 정보올림피아드 여름학교 9일차
author: mathrabbit
date: 2023-08-10 12:00:00 +0900
categories: [Problem Solving, 2023 여름학교]
tags: [camp]
math: true
---

2024-08-10 : 2024s-09 [분할정복]

[문제지](https://drive.google.com/drive/folders/1FI9ghxzaC1LfDPupFia1bb21ZwpnNj5N?usp=sharing)

## 1. 쿼드트리 (00:10:55)

모든 칸이 같으면 그 숫자를 출력하고, 그렇지 않으면 네 영역으로 분할하여 재귀를 호출하면 된다. $O(N^2 \log N)$의 시간복잡도에 문제를 해결할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
 
int n, arr[131][131];
 
void solve(int s, int e, int l, int r) {
    //cout << s << " " << e << " " << l << " " << r << "\n";
    if (s == e && l == r) {
        cout << arr[s][l];
        return;
    }
    for (int i = s; i <= e; i++) {
        for (int j = l; j <= r; j++) {
            if (arr[s][l] != arr[i][j]) {
                cout << "(";
                solve(s, (s+e)/2, l, (l+r)/2);
                solve(s, (s+e)/2, (l+r)/2 + 1, r);
                solve((s+e)/2 + 1, e, l, (l+r)/2);
                solve((s+e)/2 + 1, e, (l+r)/2 + 1, r);
                cout << ")";
                return;
            }
        }
    }
 
    cout << arr[s][l];
    return;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) cin >> arr[i][j];
    }
 
    solve(1, n, 1, n);
 
    return 0;
}
```

## 2. 곱셈 (00:21:23)

곱셈은 덧셈을 반복한 것이므로 $B$의 이진수 표현을 이용해 재귀 또는 비트마스킹으로 구현할 수 있다. 재귀를 통한 구현은 거듭제곱 구현과 동일하다. 시간 복잡도는 $O(\log B)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a, b, m, pow2[60];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> a >> b >> m;
    pow2[0] = a;
    for (int i = 1; i < 60; i++) {
        pow2[i] = (pow2[i - 1] * 2) % m;
    }
 
    ll ans = 0;
    for (int i = 0; i < 60; i++) {
        if (b & (1LL<<i)) ans = (ans + pow2[i]) % m;
    }
 
    cout << ans << "\n";
 
    return 0;
}
```

## 3. 곱셈곱셈 (00:27:16)

거듭제곱은 곱셈을 반복한 것이므로 $B$의 이진수 표현을 이용해 재귀 또는 비트마스킹을 통해 구현할 수 있다. 이 과정에 곱셈이 포함되므로 위에서 구현한 코드를 사용하자. 시간복잡도는 $O(\log M\log B)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a, b, m, pow2[60];
 
ll multiply(ll x, ll y) {
    ll ret = 0;
    pow2[0] = x % m;
    for (int i = 1; i < 60; i++) {
        pow2[i] = (pow2[i - 1] * 2) % m;
    }
    for (int i = 0; i < 60; i++) {
        if (y & (1LL<<i)) ret = (ret + pow2[i]) % m;
    }
    return ret;
}
 
ll pow(ll x, ll y) {
    if (y == 0) return 1;
 
    ll ret = pow(x, y/2);
    if (y % 2 == 0) return multiply(ret, ret);
    else return multiply(multiply(ret, ret), x);
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> a >> b >> m;
 
    cout << pow(a, b) << "\n";
 
    return 0;
}
```

## 6. 가장 가까운 두 점 (01:05:23)

well-known한 문제이다. $x$축 기준 정렬 이후 양쪽에 점이 절반씩 존재하도록 두 그룹으로 나누자. 양쪽에서 각각 최솟값 $d$를 구한 후, $d$ 이내로 떨어져 있는 나머지 점들을 $y$좌표에 대해 정렬한다. 이제 $y$좌표가 작은 쪽에서 큰 쪽으로 가면서 $y$좌표 차가 $d$ 이하인 다른 점들과의 거리를 계산한다. 이러한 점이 많아야 5개이므로 $O(N \log^2N)$의 시간에 문제를 해결할 수 있다.

하지만 $N≤1000000$이므로 충분하지 않다. 머지 소트도 기본적으로 분할을 통해 하므로 `std::sort`로 정렬하지 말고 직접 머지 소트로 정렬하자. 이러면 $O(N \log N)$의 시간에 문제를 해결할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
#define x first
#define y second
int n;
pair<int, int> point[101010], ylist[101010], temp[101010];

int dis(pair<int, int> P, pair<int, int> Q) {
    return (P.x - Q.x) * (P.x - Q.x) + (P.y - Q.y) * (P.y - Q.y);
}

int solve(int st, int ed) {
    if (st + 2 >= ed) {
        int ret = 1e9;
        for (int i = st; i <= ed; i++) ylist[i] = point[i];
        sort(ylist + st, ylist + ed + 1);
        for (int i = st; i <= ed; i++) {
            for (int j = i + 1; j <= ed; j++) {
                ret = min(ret, dis(ylist[i], ylist[j]));
            }
        }
        return ret;
    }

    int mid = (st + ed) / 2;
    int stdx = point[mid].x, d = 1e9;
    d = min(d, solve(st, mid));
    d = min(d, solve(mid + 1, ed));

    int p = st, q = mid + 1, r = st;
    while (true) {
        if (p > mid && q > ed) break;
        if (p > mid) {
            temp[r++] = ylist[q++];
            continue;
        }
        if (q > ed) {
            temp[r++] = ylist[p++];
            continue;
        }
        if (ylist[p].y <= ylist[q].y) temp[r++] = ylist[p++];
        else temp[r++] = ylist[q++];
    }
    for (int i = st; i <= ed; i++) ylist[i] = temp[i];

    r = -1;
    for (int i = st; i <= ed; i++) {
        if ((stdx - ylist[i].x) * (stdx - ylist[i].x) < d) temp[++r] = ylist[i];
    }

    for (int i = 0; i <= r; i++) {
        for (int j = i + 1; j <= r; j++) {
            if ((temp[j].y - temp[i].y) * (temp[j].y - temp[i].y) >= d) break;
            d = min(d, dis(temp[i], temp[j]));
        }
    }
    return d;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i <= n; i++) cin >> point[i].x >> point[i].y;

    sort(point + 1, point + n + 1);
    cout << solve(1, n) << "\n";

    return 0;
}
```

## 7. Hotter Colder (01:45:31)

같은 온도의 두 정점 사이에는 그것보다 더 낮은 온도의 정점이 존재해야 하므로 중심으로부터 바깥으로 갈수록 더 값이 커질 것이다. 이는 센트로이드 트리를 이용해 해결할 수 있는데, 센트로이드 트리에서 같은 깊이의 두 점 사이의 경로는 그보다 높은 깊이의 정점을 지나감이 보장되고 $O(\log N)$의 깊이를 가짐이 보장되기 때문이다. 아래는 구현 코드이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, ans[101010];
vector<int> adj[101010];
 
int ch[101010], cnt[101010];
void get_cnt(int v, int par) {
    cnt[v] = 1;
    for (int i = 0; i < adj[v].size(); i++) {
        int u = adj[v][i];
        if (ch[u]) continue;
        if (u == par) continue;
        get_cnt(u, v);
        cnt[v] += cnt[u];
    }
}
 
int get_cent(int v, int par, int sz) {
    for (int i = 0; i < adj[v].size(); i++) {
        int u = adj[v][i];
        if (ch[u]) continue;
        if (u == par) continue;
        if (2 * cnt[u] > sz) return get_cent(u, v, sz);
    }
    return v;
}
 
void solve(int v, int sz, int temp) {
    get_cnt(v, 0);
    int c = get_cent(v, 0, sz);
    get_cnt(c, 0);
    ch[c] = 1;
    ans[c] = temp;
    for (int i = 0; i < adj[c].size(); i++) {
        int nc = adj[c][i];
        if (ch[nc] == 1) continue;
        solve(nc, cnt[nc], temp + 1);
    }
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
 
    solve(1, n, 1);
    for (int i = 1; i <= n; i++) cout << ans[i] << "\n";
 
    return 0;
}
```

## 8. 유능한 코치 (02:24:05)

머지 소트 트리로 해결할 수 있다. 각 정점 $v$에 구간 $[st, ed]$에 있는 $c_i$를 모은 벡터를 저장하자. 그러면 주어진 구간 $[l, r]$이 $O(\log N)$개의 부분 구간으로 나뉘고, 각 부분 구간당 $O(\log N)$에 개수를 구할 수 있으므로 쿼리당 $O(\log^2 N)$에 해결할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 99999999;
int n, c[101010], q;
vector<int> clist[404040];
 
void init(int v, int st, int ed) {
    for (int i = st; i <= ed; i++) clist[v].push_back(c[i]);
    sort(clist[v].begin(), clist[v].end());
    if (st == ed) return;
    int mid = (st + ed) / 2;
    init(2 * v, st, mid);
    init(2 * v + 1, mid + 1, ed);
}
 
int get(int v, int st, int ed, int lt, int rt, int r) {
    if (lt > ed || st > rt) return 0;
    if (lt <= st && ed <= rt) {
        return lower_bound(clist[v].begin(), clist[v].end(), r) - clist[v].begin();
    }
    int mid = (st + ed) / 2;
    return get(2 * v, st, mid, lt, rt, r) + get(2 * v + 1, mid + 1, ed, lt, rt, r);
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> c[i];
    init(1, 1, n);
 
    int ans = 0;
    for (int i = 1; i <= q; i++) {
        int s, e, h;
        cin >> s >> e >> h;
        ans = get(1, 1, n, s, e, ((ll)ans * i + h) % MOD + 1);
        cout << ans << "\n";
    }
 
    return 0;
}
```

## 9. 애플파이 (02:47:16)

dnc opt를 사용하자. dnc opt는 어떤 $\max_{1≤j≤n} f(i, j)$를 구할 때 최댓값에 해당하는 $k(i)$가 $i$에 대해 단조성을 보일 때 사용할 수 있는 최적화로, 만약 $k(i)$가 단조증가라면 구간 $[m + 1, n]$에서는 $k(m)$ 이상인 $j$만 고려해도 되고, $[1, m-1]$에서는 $k(m)$ 이하인 $j$만 고려해도 된다. 즉, 재귀 호출의 깊이가 $O(\log N)$이므로 $O(N\log N)$에 모든 $i$에 대해 값을 구할 수 있음이 보장된다.

우리가 구해야하는 값은

$$
f(i)=\max_{i≤j≤i+D} {(j-i)T_j + V_i}
$$

이고, 일단 편의를 위해 구간을 $1≤j≤n$으로 통일하자. 이제 주어진 $T_1 ≥ T_2 ≥ \cdots ≥ T_n$의 조건을 이용하면 $(k-1-i)T_{k-1} \leq(k-i)T_k \geq (k+1-i)T_{k+1}$인 $k$에 대해 $f(i+1)$의 최댓값과 관련 식 $(k+1-i)T_k ≥ (k+2-i)T_{k+1}$가 성립하므로 $i$가 증가하면 $k(i)$가 증가한다. 따라서 dnc opt를 사용할 수 있다.

dnc opt를 사용한 후 $k>i+D$인 경우에는 $j=i+D$일 때 가장 값이 클 것이므로 이 경우에만 예외처리를 하자.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, d;
ll tem[101010], qua[101010], opt[101010];
 
void solve(ll s, ll e, ll l, ll r) {
    if (s > e) return;
    ll m = (s + e) / 2, k;
    for (ll i = l; i <= r; i++) {
        if (i < m) continue;
        if (opt[m] < (i - m) * tem[i] + qua[m]) {
            opt[m] = (i - m) * tem[i] + qua[m];
            k = i;
        }
    }
    if (k - m > d) opt[m] = d * tem[m + d] + qua[m];
    solve(s, m - 1, l, k);
    solve(m + 1, e, k, r);
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> d; 
    for (int i = 1; i <= n; i++) cin >> tem[i];
    for (int i = 1; i <= n; i++) cin >> qua[i];
    for (int i = 1; i <= n; i++) opt[i] = -1;
 
    solve(1, n, 1, n);
 
    ll ans = 0;
    for (int i = 1; i <= n; i++) ans = max(ans, opt[i]);
    cout << ans << "\n";
 
    return 0;
}
```

## 10. 점수

아래 세 가지 관찰을 차례로 하면 된다.

- 관찰 1. $a_i \leq a_j$이고 $b_i \leq b_j$일 때 $j$번째 A반 학생은 고려할 필요가 없다. 마찬가지로, $p_i ≥ p_j$이고 $q_i≥q_j$일 때 $j$번째 B반 학생은 고려할 필요가 없다. 이를 이용해 $O(N+M)$에 고려해야 하는 학생만 남길 수 있다.
- 관찰 2. 관찰 1을 시행하고 남은 학생들만 생각할 때 $a_i < a_j$이면 $b_i > b_j$이다. 마찬가지로 $p_i > p_j$이면 $q_i < q_j$이다.
- 관찰 3. 각 $(p_i, q_i)$에 대해 $f(i, j)=(p_i - a_j)(q_i - b_j)$가 최대인 $j$를 $k(i)$라고 하자. 관찰 2의 부등식 관계로 아래를 증명할 수 있다. 즉, $k(i)$는 단조감소한다.

$$
(p_i - a_k)(q_i-b_k)>(p_i-a_{k+1})(q_i-b_{k+1}) \Rarr (p_{i+1} - a_k)(q_{i+1}-b_k)>(p_{i+1}-a_{k+1})(q_{i+1}-b_{k+1})
$$

이를 이용해 dnc opt를 할 수 있다. 9번 문제와 같이 $p_i < a_k$ 또는 $q_i < b_k$인 경우를 찾아 예외처리를 하자.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m;
pair<ll, ll> A[505050], ptA[505050], B[505050], ptB[505050];
vector<ll> flist, slist;
ll opt[505050], ans = 0, ans2 = 0;
 
ll f(int a, int b) {
    //cout << a << " " << b << "\n";
    return (ptB[b].first - ptA[a].first) * (ptB[b].second - ptA[a].second);
}
 
void solve(int s, int e, int l, int r) {
    if (s > e) return;
    int m = (s + e) / 2, k;
    for (int i = l; i <= r; i++) {
        if (opt[m] <= f(i, m)) {
            opt[m] = f(i, m);
            k = i;
        }
    }
    int st = slist.size() + 1 - (lower_bound(slist.begin(), slist.end(), ptB[m].second) - slist.begin());
    int ed = lower_bound(flist.begin(), flist.end(), ptB[m].first) - flist.begin();
    if (st > ed) opt[m] = 0;
    else if (k < st) opt[m] = f(st, m);
    else if (k > ed) opt[m] = f(ed, m);
 
    solve(s, m - 1, k, r);
    solve(m + 1, e, l, k);
}
 
void naive(ll p, ll q) {
    for (int i = 1; i <= n; i++) {
        if (p <= A[i].first || q <= A[i].second) continue;
        ans2 = max(ans2, (p - A[i].first) * (q - A[i].second));
    }
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> A[i].first >> A[i].second;
    sort(A + 1, A + n + 1);
 
    int r = 0; ll val = A[1].second;
    ptA[++r] = A[1];
    for (int i = 2; i <= n; i++) {
        if (val > A[i].second) {
            val = A[i].second;
            ptA[++r] = A[i];
        }
    }
 
    for (int i = 1; i <= r; i++) flist.push_back(ptA[i].first);
    for (int i = 1; i <= r; i++) slist.push_back(ptA[i].second);
    reverse(slist.begin(), slist.end());
 
    for (int i = 1; i <= m; i++) cin >> B[i].first >> B[i].second;
    sort(B + 1, B + m + 1);
 
    int s = 0; val = B[m].second;
    ptB[++s] = B[m];
    for (int i = m - 1; i >= 1; i--) {
        if (val < B[i].second) {
            val = B[i].second;
            ptB[++s] = B[i];
        }
    }
 
    //for (int i = 1; i <= r; i++) cout << "A " << ptA[i].first << " " << ptA[i].second << "\n";
    //for (int i = 1; i <= s; i++) cout << "B " << ptB[i].first << " " << ptB[i].second << "\n";
 
    for (int i = 1; i <= s; i++) opt[i] = 0;
    solve(1, s, 1, r);
    
    for (int i = 1; i <= s; i++) ans = max(ans, opt[i]);
    cout << ans << "\n";
 
    //for (int i = 1; i <= m; i++) naive(B[i].first, B[i].second);
    //cout << ans2 << "\n";
 
    return 0;
}
```

## 4. 비밀번호 찾기

$n$자리 자연수 곱셈을 구현하면 된다. 강의 자료를 참고하면 $n/2$자리씩 끊어서 곱셈하는 방식으로 $O(n^{\log_2 3})$의 시간에 구할 수 있고, 이 횟수는 $60000$번 미만이기 때문에 문제를 해결할 수 있게 된다.

구체적으로 어떤 두 수 $X, Y$가 $X=Ax^{n/2}+B$와 $Y=Cx^{n/2}+D$로 표시가 된다면, $XY$는

$$
XY=ACx^n + [(A-B)(D-C)+AC+BD]x^{n/2}+BD
$$

이므로 $3$번의 곱셈으로 구할 수 있다. 따라서 $T(n) = 3T(n/2)+O(n)$이므로 $T(n)=O(n^{\log_2 3})$이다. 아래는 구현 코드이다. 항등원이 뭔지 몰라 $0$을 쓸 수 없다는 사실에 유념하자. $N=1000$에서 실제 호출 횟수는는 $58779$번이다.

```cpp
#include "password.h"
#include <bits/stdc++.h>
using namespace std;

vector<unsigned int> solve(vector<unsigned int> X, vector<unsigned int> Y) {
    int n = X.size(), m = n/2;

    if (n == 1) return {mul(X[0], Y[0])};

    vector<unsigned int> A, B, C, D, AmB, CmD, AC, BD, MID, ret(2*n-1);
    for (int i = 0; i < n; i++) {
        if (i < m) B.push_back(X[i]);
        else A.push_back(X[i]);
    }
    for (int i = 0; i < n; i++) {
        if (i < m) D.push_back(Y[i]);
        else C.push_back(Y[i]);
    }

    for (int i = 0; i < m; i++) AmB.push_back(sub(A[i], B[i]));
    if (A.size() > m) AmB.push_back(A[m]);
    for (int i = 0; i < m; i++) CmD.push_back(sub(C[i], D[i]));
    if (C.size() > m) CmD.push_back(C[m]);

    AC = solve(A, C);
    BD = solve(B, D);
    MID = solve(AmB, CmD);
    for (int i = 0; i < 2*n-2*m-1; i++) MID[i] = sub(AC[i], MID[i]);
    for (int i = 0; i < 2*m-1; i++) MID[i] = add(MID[i], BD[i]);

    for (int i = 0; i < 2*m-1; i++) ret[i] = BD[i];
    ret[2*m-1] = MID[m-1];
    for (int i = 2*m; i < 2*n-1; i++) ret[i] = AC[i-2*m];
    for (int i = m; i < 2*n-m-1; i++) if (i != 2*m-1) ret[i] = add(ret[i], MID[i-m]);
    return ret;
}

vector<unsigned int> find_password(vector<unsigned int> A, vector<unsigned int> B) {
    return solve(A, B);
}
```

## 5. 프로 선수

일단 같은 숫자가 세 개 존재하는 경우에는 어떤 수열도 조건을 만족할 수 없다. 또한, 같은 숫자가 두 개 존재하는 경우에는 같은 숫자가 세 개 연속해야 옥토끼가 찾아야 하는 조건을 만족하기 때문에, 그냥 붙여 놓아도 문제되지 않는다. 따라서 같은 숫자 두 개는 붙여 놓으면 된다. 따라서 모든 상황을 모든 수가 다른 경우 또는 불가능한 경우로 환원할 수 있다.

(풀이 모르겠음)