---
title: 2023학년도 정보올림피아드 여름학교 1일차
author: mathrabbit
date: 2023-08-02 12:00:00 +0900
categories: [Problem Solving, 2023 여름학교]
tags: [camp]
math: true
---

2024-08-02 : 2024s-01 [이산수학]

[문제지](https://drive.google.com/drive/folders/1EvoUhhW9rfs3h-cG1opbQ9zanEJ4XhTG?usp=drive_link)

## 1. 피보나치 수열 (00:03:02)

$n≤50$까지 피보나치 수 출력하면 된다. `int`로 부족함에 유의할 것!

시간복잡도: $O(N)$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
ll dp[55];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    dp[1] = dp[2] = 1;
    for (int i = 3; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2];
    cout << dp[n] << "\n";
 
    return 0;
}
```

## 2. 순열 (00:24:37)

주어진 순열이 몇 번째이고, 다음 순열이 무엇인지 출력하면 된다. $i$번째 숫자까지 같은 순열은 $(n-i)(n-i-1) \cdots (n-k+1)$개 존재함을 이용하면 몇 번째인지 찾을 수 있다. 다음 번 순열은, 올림이 마지막으로 일어나는 지점까지 거슬러 올라간 후 올림이 일어난 부분은 첫 번째 순열로 채우면 된다.

시간복잡도: $O(nk)$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, k, arr[5050], ch[5050];
ll MOD = 1e9 + 9, fac[5050], ans = 0;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> k;
 
    fac[k] = 1;
    for (int i = k - 1; i >= 1; i--) fac[i] = (fac[i + 1] * (n - i)) % MOD;
 
    for (int i = 1; i <= k; i++) cin >> arr[i];
 
    for (int i = 1; i <= k; i++) {
        ll cnt = 0;
        for (int j = 1; j < arr[i]; j++) if (ch[j] == 0) cnt += 1;
        ans = (ans + cnt * fac[i]) % MOD;
        ch[arr[i]] = 1;
    }
 
    ans++;
 
    cout << ans << "\n";
 
    for (int i = k; i >= 1; i--) {
        int j = arr[i] + 1;
        ch[arr[i]] = 0;
        while (ch[j] == 1) j++;
        if (j <= n) {
            arr[i] = j;
            ch[arr[i]] = 1;
            break;
        }
        arr[i] = 0;
    }
 
    for (int i = 1; i <= n; i++) ch[i] = 0;
    for (int i = 1; i <= k; i++) {
        if (arr[i] == 0) {
            for (int j = 1; j <= n; j++) {
                if (ch[j] == 0) {
                    arr[i] = j;
                    break;
                }
            }
        }
        cout << arr[i] << " ";
        ch[arr[i]] = 1;
    }
 
    return 0;
}
```

## 3. 조합 (00:34:37)

주어진 조합이 몇 번째이고, 다음 조합이 무엇인지 출력하면 된다. 몇 번째인지 출력하는 것은 순열보다 어려운데 $i$번쨰 자리라고 모두 동일한 것이 아니라, 현재 숫자에 따라 뒤에 올 수 있는 조합의 개수가 달라지기 때문이다. 반면 다음 조합을 출력하는 것은 순열보다 쉬운데, 순열은 이미 나온 값을 관리해줘야 하지만, 조합은 이전 값보다 크면 되기 때문이다. 조합의 경우도 똑같이 올림이 마지막으로 일어나는 지점까지 거슬러 올라간 후 올림이 일어난 부분은 첫 번째 조합(앞 수에 1을 더한 값)으로 채우면 된다.

시간복잡도: $O(nk)$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, k, arr[5050], ch[5050];
ll MOD = 1e9 + 9, comb[5050][5050], ans = 0;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> k;
 
    comb[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        comb[i][0] = 1;
        for (int j = 1; j <= k; j++) {
            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
        }
    }
 
    for (int i = 1; i <= k; i++) cin >> arr[i];
 
    for (int i = 1; i <= k; i++) {
        for (int j = arr[i - 1] + 1; j < arr[i]; j++) ans = (ans + comb[n - j][k - i]) % MOD;
    }
    cout << (ans + 1) % MOD << "\n";
 
    for (int i = k; i >= 1; i--) {
        if (arr[i] < i + n - k) {
            arr[i] += 1;
            break;
        }
        arr[i] = 0;
    }
 
    for (int i = 1; i <= k; i++) {
        if (arr[i] == 0) arr[i] = arr[i - 1] + 1;
        cout << arr[i] << " ";
    }
 
    return 0;
}
```

## 5. 조합

$_n C_m$을 구하는 문제인데, 제한이 $0≤m≤n≤L≤10^7$이고, 총 $1≤K≤10^7$개의 $_n C_m$의 답을 빠르게 구해야 한다. 

### 85점 (00:44:39)

제한: $L≤10^5, K≤10^5$

소수 $10^9+7$로 나눈 나머지를 구하는 문제이기 때문에, $O(L \log X)$의 시간에 $N!$과 그 잉여역수를 모두 전처리하고 각 쿼리마다 $O(1)$의 시간에 처리할 수 있다. 따라서 시간복잡도 $O(L \log X + K)$에 답을 구할 수 있다. 함수 구현형(IOI 스타일) 문제임에 유의하자.

```cpp
#include "ncm.h"
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
 
ll fac[10101010], inv[10101010];
ll m, n;
ll MOD = 1e9 + 7;
 
ll power(ll a, ll p) {
    if (p == 0) return 1LL;
    ll ret = power(a, p/2);
    if (p % 2 == 0) return (ret * ret) % MOD;
    else return (((ret * ret) % MOD) * a) % MOD;
}
 
void init(int l) {
    fac[0] = 1;
    for (int i = 1; i <= l; i++) fac[i] = (fac[i - 1] * i) % MOD;
    for (int i = 0; i <= l; i++) inv[i] = power(fac[i], MOD - 2);
}
 
int ncm(int n, int m) {
    return (((fac[n] * inv[m]) % MOD) * inv[n - m]) % MOD;
}
```

### 100점

$L!$의 역원을 모두 구한 후 $L$을 곱하면 $(L-1)!$의 역원이 된다. 이를 반복하면 역원을 $O(L)$의 시간에 계산할 수 있다. 따라서 시간복잡도 $O(L+K)$에 AC를 받을 수 있다.

```cpp
#include "ncm.h"
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
 
ll fac[10101010], inv[10101010];
ll m, n;
ll MOD = 1e9 + 7;
 
ll power(ll a, ll p) {
    if (p == 0) return 1LL;
    ll ret = power(a, p/2);
    if (p % 2 == 0) return (ret * ret) % MOD;
    else return (((ret * ret) % MOD) * a) % MOD;
}
 
void init(int l) {
    fac[0] = 1;
    for (int i = 1; i <= l; i++) fac[i] = (fac[i - 1] * i) % MOD;
  	inv[l] = power(fac[l], MOD - 2);
    for (int i = l - 1; i >= 0; i--) inv[i] = (inv[i + 1] * (i + 1)) % MOD;
}
 
int ncm(int n, int m) {
    return (((fac[n] * inv[m]) % MOD) * inv[n - m]) % MOD;
}
```

## 4. 정원 (01:48:37)

참고: IOI 2008 4번 (https://www.acmicpc.net/problem/5470)

$N$개의 `M, R`로 이루어져 있고, 임의의 부분 문자열을 잡았을 때 두 문자의 개수 차이가 $2$ 이하인 모든 문자열을 사전순으로 배열했을 떄, 주어진 문자열이 몇 번째인지 출력하는 문제이다. 일단, 아래와 같이 점화식을 잡자.

- 정의: $dp_{i, k, l}$은 길이 $i$인 문자열 중, 구간 $[s, i]$에서 `M`이 더 많은 경우 그 차이의 최댓값이 $k$이고, `L`이 더 많은 경우 그 차이의 최댓값이 $l$인 문자열의 개수
- 점화식
    
    $$
    dp_{i+1, k+1, \max(l-1, 0)} \larr dp_{i, k, l}
    $$
    
    $$
    dp_{i+1, \max(k-1, 0), l+1} \larr dp_{i, k, l}
    $$
    

이 값들을 이용해 주어진 문자열이 사전순으로 몇 번째인지 구하자. `M`인 부분은 사전순으로 가장 앞서므로 무시할 수 있고, `R`인 부분은 그 위치에 `M`이 있는 다른 문자열들 뒤에 나오므로 그 문자열의 개수를 더해야 한다. 그 문자열의 개수는 $i$번째 문자가 `R`일 때, $i$번째 문자가 `M`인 경우의 $k$와 $l$(정의는 위와 동일함)을 이용해 $dp_{n-i, 2-k, 2-l}$로 계산할 수 있다. 따라서 모든 `R`에 대해 저 값을 전부 더하고 $1$을 더하면 답이 된다.

시간복잡도: $O(N)$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m, arr[1010101];
int dp[1010101][3][3];
 
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        char c;
        cin >> c;
        if (c == 'M') arr[i] = 0;
        else arr[i] = 1;
    }
 
 
    dp[0][0][0] = 1;
    for (int i = 0; i < n; i++) {
        for (int k = 0; k <= 2; k++) {
            for (int l = 0; l <= 2; l++) {
                if (k < 2) dp[i + 1][k + 1][max(l - 1, 0)] += dp[i][k][l];
                if (l < 2) dp[i + 1][max(k - 1, 0)][l + 1] += dp[i][k][l];
            }
        }
        for (int k = 0; k <= 2; k++) {
            for (int l = 0; l <= 2; l++) {
                dp[i + 1][k][l] %= m;
            }
        }
    }
 
    for (int i = 1; i <= n; i++) {
        for (int k = 0; k <= 2; k++) {
            for (int l = 0; l <= 2; l++) {
                //cout << i << " " << l << " " << k << " " << dp[i][k][l] << "\n";
            }
        }
    }
 
    int kval = 0, lval = 0, ans = 0;
    for (int i = 1; i <= n; i++) {
        if (arr[i] == 0) {
            kval += 1;
            lval = max(lval - 1, 0);
        }
        if (arr[i] == 1) {
            if (kval < 2) {
                for (int k = 0; k <= 1 - kval; k++) {
                    for (int l = 0; l <= 2 - max(lval - 1, 0); l++) {
                        ans = (ans + dp[n - i][k][l]) % m;
                    }
                }
            }
            lval += 1;
            kval = max(kval - 1, 0);
        }
    }
    cout << (ans + 1) % m << "\n";
    return 0;
}
```

## 7. 부등호 (02:33:00)

주어진 부등호 조건을 만족하는 $N$자리 수열의 개수를 찾는 문제이다. 간단히 2차원 dp로 해결할 수 있다.

- 정의: $dp_{i, k}$는 $1$부터 $i$까지의 수로 이루어져 있고, 마지막 숫자가 $k$이며 조건을 만족하는 순열의 개수
- 초깃값: $dp_{1, 1}=1$
- 점화식
    - $A_i < A_{i+1}$을 만족해야 하는 경우
        
        $$
        dp_{i, k}= \sum_{j=1}^{k-1} {dp_{i - 1, j}}
        $$
        
    - $A_i > A_{i+1}$을 만족해야 하는 경우
        
        $$
        dp_{i, k}= \sum_{j=k}^{i-1} {dp_{i - 1, j}}
        $$
        

합을 naive하게 구할 경우 $O(N^3)$의 시간복잡도지만, 부분 합을 이용할 경우 $O(N^2)$에 처리 가능하다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, arr[3030];
ll MOD = 1e9 + 7, dp[3030][3030], sum[3030][3030];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    string s;
    cin >> s;
    n = s.length() + 1;
    for (int i = 1; i < n; i++) {
        if (s[i - 1] == '<') arr[i] = 1;
        else arr[i] = 0;
    }
 
    dp[1][1] = 1;
    sum[1][1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int k = 1; k <= i; k++) {
            if (arr[i - 1]) dp[i][k] = sum[i - 1][k - 1];
            else dp[i][k] = (sum[i - 1][i - 1] - sum[i - 1][k - 1] + MOD) % MOD;
        }
        for (int k = 1; k <= i; k++) sum[i][k] = (sum[i][k - 1] + dp[i][k]) % MOD;
        //for (int k = 1; k <= i; k++) cout << dp[i][k] << " ";
        //cout << "\n";
    }
 
    cout << sum[n][n] << "\n";
 
    return 0;
}
```

## 8. XOR과 합 (02:46:13)

주어진 수열에서 $A_l \oplus A_{l+1} \oplus \cdots \oplus A_r = A_l + A_{l+1} + \cdots + A_r$을 만족하는 순서쌍 $(l, r)$을 모두 찾는 문제이다. 

먼저 $0≤A_i < 2^{20}$이므로 모든 숫자의 비트를 따로 저장하는 배열을 만들자. 주어진 조건을 해석해보면, 좌변이 우변보다 항상 이하이고, 등호가 성립할 조건은 $[l, r]$에서 모든 비트가 최대 1번 등장하는 경우임을 알 수 있다.

따라서 `sliding window`로 만약 2번 등장하는 비트가 있으면 범위를 줄이고 없으면 범위를 늘리며 답을 구할 수 있고, 개수는 범위가 늘어날 때 그 구간의 길이만큼 증가함을 알 수 있다.

시간복잡도: $O(n \log X)$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, arr[202020][20], now[20];
ll ans = 0;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int t;
        cin >> t;
        for (int j = 0; j < 20; j++) {
            if ((1<<j) & t) arr[i][j] = 1;
            else arr[i][j] = 0;
        }
    }
 
    int p = 1, q = 0;
    while (true) {
        if (p > n) break;
        if (q == n) break;
        int f = false;
        for (int j = 0; j < 20; j++) if (now[j] + arr[q + 1][j] > 1) f = true;
        if (f) {
            for (int j = 0; j < 20; j++) now[j] -= arr[p][j];
            p++;
        }
        else {
            q++;
            for (int j = 0; j < 20; j++) now[j] += arr[q][j];
            ans += (ll)(q - p + 1);
            //cout << p << " " << q << "\n";
        }
    }
 
    cout << ans << "\n";
 
    return 0;
}
```

## 6. 트리 칠하기

$S_1$을 구하는 것을 생각해보자. 주어진 문제의 조건을 해석하면, 최초에 검은색인 정점부터 시작해 쭉 따라 내려가면서 중간에 멈춘 모든 상태가 가능하다. 즉, 모든 검은색인 정점은 연결되어 있어야 한다.

이제 이를 dp를 통해 구해보자. 각 정점의 자식 노드는 색칠되지 않거나 색칠된다. 만약 색칠된 경우에는 그 정점을 루트로 하는 부분트리에서 동일한 부분 문제를 갖게 된다. 따라서, 각 자식 노드에서의 답에 1을 더한 수를 모두 곱한 것이 답이다.

$$
dp_v = \sum_{u \textrm{~is child of~}v} (dp_u+1)
$$

하지만 각 $S_i$를 이렇게 구할 경우 $O(N)$의 시간복잡도를 가지므로 $O(N^2)$으로 TLE가 난다. 사실 잘 보면, 구한 $dp$ 값이 중복해서 사용되고 있음을 알 수 있다. 이 중복을 줄이면 시간복잡도를 줄일 수 있을 것이다.

$1$번 노드와 $1$번 노드의 자식 노드 $v$ 사이에서 겹치는 부분을 생각해보자. 일단 $v$와 연결된 모든 자식 노드 중, $1$번 노드가 아닌 노드는 $dp$값들을 알고 있다. 문제는 $1$번 노드와 연결된 부분의 $dp$ 값을 구하는건데, 그 값은 원래 $1$번 노드의 $dp$ 값에서 $dp_v$를 나누고 $1$을 더한 값이다.

하지만 MOD가 소수가 아니기 때문에, 잉여역수를 사용할 수는 없고 다른 방법을 생각하여야 한다. 그 방법은 $1$번 노드와 연결된 $dp$ 값들을 리스트로 저장한 후 앞에서부터의 부분 곱과 뒤에서부터의 부분 곱을 저장한 후 두 값을 곱해서 계산할 수 있다. 구현이 약간 복잡하지만, 이렇게 계산하면 $O(N)$의 시간에 문제를 해결할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, ch[252525];
vector<int> adj[252525];
vector<ll> child[252525], dp2[252525], lt[252525], rt[252525];
ll dp[252525], p, ans[252525];
 
void DFS(int v) {
    ch[v] = 1;
    dp[v] = 1;
    for (int i = 0; i < adj[v].size(); i++) {
        int next = adj[v][i];
        if (ch[next] == 1) continue;
        DFS(next);
        child[v].push_back(next);
        dp2[v].push_back(dp[next]);
        dp[v] = (dp[v] * dp[next]) % p;
    }
    dp[v] = (dp[v] + 1) % p;
 
    ll t = 1;
    for (int i = 0; i < dp2[v].size(); i++) {
        t = (t * dp2[v][i]) % p;
        lt[v].push_back(t);
    }
    t = 1;
    for (int i = dp2[v].size() - 1; i >= 0; i--) {
        t = (t * dp2[v][i]) % p;
        rt[v].push_back(t);
    }
}
 
void solve(int v, ll val, ll cof) {
    ans[v] = val;
    for (int i = 0; i < child[v].size(); i++){
        int next = child[v][i];
        ll nval = (dp[next] - 1 + p)% p;
        ll here = cof;
        if (i > 0) here = (here * lt[v][i - 1]) % p;
        if (i < lt[v].size() - 1) here = (here * rt[v][lt[v].size() - i - 2]) % p;
        solve(next, (nval * (here + 1)) % p, (here + 1) % p);
    }
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> p;
    for (int i = 1; i < n; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
 
    for (int i = 1; i <= n; i++) ch[i] = 0;
    DFS(1);
 
    solve(1, dp[1] - 1, 1);
    for (int i = 1; i <= n; i++) cout << ans[i] << "\n";
 
    return 0;
}
```

## 9. 블록 점수

$N$개의 점들의 집합의 부분집합 중 볼록 껍질인 집합들 $S$에 대해 $S$ 안에 속하는 점의 개수를 $n$이라 하자. 이 문제의 목표는 각 $S$에 대해 $2^{n-\vert S \vert}$의 합을 구하는 것이다.

$2^{n - \vert S \vert}$를 잘 보면, $S$에 속하지 않고, 내부에 있는 점들의 부분 집합의 개수와 같다. 즉, $S$의 내부에 있고 $S$에 속하지 않는 점들의 집합을 $T$라고 하면, $T$의 부분 집합 $U$에 대해 $S$와 $U$의 합집합마다 하나씩 세는 것이라고 생각할 수 있다.

이제 다시 반대로 $S$와 $U$의 합집합 $A$를 생각하자. 이 $A$의 가장 바깥 볼록 껍질이 존재한다면, 그 볼록 껍질이 $S$가 되고, 나머지 부분이 $U$가 될 것이다. 즉, 볼록 껍질이 존재하는 점의 집합의 개수를 세는 문제가 된다.

볼록 껍질이 존재할 조건은, 모든 점이 일직선이 아닐 조건이고, $O(N^3)$의 시간에 일직선인 점들의 쌍을 찾을 수 있으므로, 조합적으로 답을 구할 수 있다. 이 과정에서 중복으로 세어지지 않도록, 이미 세 점이 직선을 이루는 세 점에 포함된 두 점의 쌍은 `ch` 배열로 마킹도록 하자.

시간복잡도: $O(N^3)$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll, ll> pll;
#define x first
#define y second
 
int n, ch[220][220];
vector<int> line[220][220];
pll arr[220];
ll ans = 1, MOD = 998244353, comb[220][220];
 
ll CCW(pll a, pll b, pll c) {
    return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    comb[0][0] = 1;
    for (int i = 1; i <= 200; i++) {
        comb[i][0] = 1;
        for (int j = 1; j <= i; j++) {
            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
        }
    }
 
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> arr[i].x >> arr[i].y;
 
    for (int i = 1; i <= n; i++) ans = (ans * 2) % MOD;
 
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            line[i][j].push_back(i);
            line[i][j].push_back(j);
            if (ch[i][j]) continue;
            for (int k = j + 1; k <= n; k++) {
                if (CCW(arr[i], arr[j], arr[k]) == 0) line[i][j].push_back(k);
            }
            for (int a = 0; a < line[i][j].size(); a++) {
                for (int b = a + 1; b < line[i][j].size(); b++) {
                    ch[line[i][j][a]][line[i][j][b]] = 1;
                }
            }
        }
    }
 
    ans = (ans - n * (n + 1) / 2 - 1 + MOD) % MOD;
 
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            int s = line[i][j].size();
            for (int k = 3; k <= s; k++) ans = (ans - comb[s][k] + MOD) % MOD;
        }
    }
 
    cout << ans << "\n";
 
    return 0;
}
```

## 10. Jelly Flavors

문제의 조건을 해석하면 주어진 $N$개의 두 수의 순서쌍 중 임의의 두 순서쌍 $(a, b), (c, d)$를 골라, $_{a+b+c+d} C_{a+c}$의 합을 구하는 문제임을 쉽게 알 수 있다. 만약 가능한 모든 경우를 생각한다면 $O(N^2)$으로 TLE를 받기 때문에 다른 방법을 생각해보자.

### $O(NX)$

쉽게 $a≤2000, b≤2000$의 제약조건에 집중해야 함을 파악할 수 있다. 이로부터 다음과 같은 함수

$$
f(x, y)= \sum_{i=1}^N {_{a_i+b_i+x+y} C_{a_i+x}}
$$

 를 생각하자. 만약 우리가

$$
S=\sum_{i=1}^N f(a_i, b_i)
$$

를 구할 수 있다면, $S$에서 $\sum_{i=1}^N {_{2a_i+2b_i}C_{2a_i}}$을 빼고 2로 나눔으로써 답을 구할 수 있을 것이다. 그러면 이제 빠르게 $f(x, y)$를 구하는 방법을 생각해보자. $f(x, y)$의 식 꼴을 자세해 보면 $_n C_r = _{n-1}C_r+ _{n-1}C_{r-1}$이 성립하므로, $f(x, y)=f(x-1, y)+f(x, y-1)$의 식이 성립함을 알 수 있다. 하지만, 초깃값으로 $f(x, 0)$과 $f(0, y)$ 꼴의 모든 값을 계산하여야 하고, 각 계산에 $O(N)$이 소요되므로, $O(NX)$의 시간복잡도가 되어 TLE를 받는다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
 
int n, arr[202020][2];
ll MOD = 1e9 + 7, comb[8080][8080];
ll sum[2020][2020];
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    comb[0][0] = 1;
    for (int i = 1; i <= 8000; i++) {
        comb[i][0] = 1;
        for (int j = 1; j <= i; j++) {
            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
        }
    }
 
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> arr[i][0] >> arr[i][1];
    for (int i = 1; i <= n; i++) {
        sum[0][0] = (sum[0][0] + comb[arr[i][0] + arr[i][1]][arr[i][0]]) % MOD;
        for (int k = 1; k <= 2000; k++)
            sum[k][0] = (sum[k][0] + comb[arr[i][0] + arr[i][1] + k][arr[i][0] + k]) % MOD;
        for (int k = 1; k <= 2000; k++)
            sum[0][k] = (sum[0][k] + comb[arr[i][0] + arr[i][1] + k][arr[i][0]]) % MOD;
    }
 
    for (int k = 1; k <= 4000; k++) {
        for (int i = 1; i < k; i++) {
            int j = k - i;
            if (i > 2000 || j > 2000) continue;
            sum[i][j] = (sum[i][j - 1] + sum[i - 1][j]) % MOD;
        }
    }
 
    ll ans = 0;
    for (int i = 1; i <= n; i++) {
        ans = (ans + sum[arr[i][0]][arr[i][1]]) % MOD;
    }
 
    for (int i = 1; i <= n; i++) {
        ans = (ans - comb[2 * arr[i][0] + 2 * arr[i][1]][2 * arr[i][0]] + MOD) % MOD;
    }
 
    if (ans % 2 == 0) cout << ans / 2 << "\n";
    else cout << (ans + MOD) / 2 << "\n";
 
    return 0;
}
```

### $O(X^2)$

정해는 격자를 사용하는 것은 비슷하나 다른 관점으로 접근하는 것이다. 이항계수는 격자에서 이동하는 경우의 수와 동일하다는 것은 모두가 알고 있는 사실이다. 이를 이용하면 $N$개의 3사분면상의 점 $(-a_i, -b_i)$에서 $N$개의 1사분면상의 점 $(a_i, b_i)$로 이동하는 경우의 수의 총 합이 $S$와 같음을 확인할 수 있다. 이후 격자에서 이동하는 경우의 수를 세는 방법과 동일하게 답을 구하면 될 것이다. 시간복잡도는 $O(X^2)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
 
int n, arr[202020][2];
ll grid[4040][4040], comb[8080][8080];
ll MOD = 1e9 + 7;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    comb[0][0] = 1;
    for (int i = 1; i <= 8000; i++) {
        comb[i][0] = 1;
        for (int j = 1; j <= i; j++) {
            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
        }
    }
 
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> arr[i][0] >> arr[i][1];
    for (int i = 1; i <= n; i++) grid[2000 - arr[i][0]][2000 - arr[i][1]] += 1;
 
    for (int i = 0; i <= 4000; i++) {
        for (int j = 0; j <= 4000; j++) {
            grid[i][j] += ((i > 0 ? grid[i - 1][j] : 0) + (j > 0 ? grid[i][j - 1] : 0)) % MOD;
        }
    }
 
    ll ans = 0;
    for (int i = 1; i <= n; i++) {
        ans = (ans + grid[arr[i][0] + 2000][arr[i][1] + 2000]) % MOD;
    }
 
    for (int i = 1; i <= n; i++) {
        ans = (ans - comb[2 * arr[i][0] + 2 * arr[i][1]][2 * arr[i][0]] + MOD) % MOD;
    }
 
    if (ans % 2 == 0) cout << ans / 2 << "\n";
    else cout << (ans + MOD) / 2 << "\n";
 
    return 0;
}
```

## 11. Painting

$1$부터 $N$까지의 수로 구분되는 공 $K$개, 즉 총 $NK$개의 공을 나열한 후, 각 숫자에 해당하는 공마다 가장 왼쪽에 있는 공을 $0$번 공으로 바꿀 때 나올 수 있는 모든 순열의 종류의 가짓수를 구하는 문제이다.