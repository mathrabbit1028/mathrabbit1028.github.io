---
title: 2023학년도 정보올림피아드 여름학교 7일차
author: mathrabbit
date: 2023-08-08 12:00:00 +0900
categories: [Problem Solving, 2023 여름학교]
tags: [camp]
math: true
---

2024-08-08 : 2024s-07 [자료구조 2]

[문제지](https://drive.google.com/drive/folders/1IKFoxh_jSEHRDnr7RE8kaVwaAapwq8xz?usp=sharing)

## 1. 순회 (00:08:52)

전위순회, 중위순회, 후위순회를 재귀로 구현해 출력하자. 루트는 $l_i$ 및 $r_i$에 한 번도 등장하지 않는 정점이라는 관찰이 필요하다.

```cpp
#include <bits/stdc++.h>
using namespace std;
 
int n, ch[505050], l[505050], r[505050];
 
void pre(int v) {
    if (v == 0) return;
    cout << v << " ";
    pre(l[v]);
    pre(r[v]);
}
 
void in(int v) {
    if (v == 0) return;
    in(l[v]);
    cout << v << " ";
    in(r[v]);
}
 
void post(int v) {
    if (v == 0) return;
    post(l[v]);
    post(r[v]);
    cout << v << " ";
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> l[i] >> r[i];
 
    for (int i = 1; i <= n; i++) ch[l[i]] = ch[r[i]] = 1;
    
    int r;
    for (int i = 1; i <= n; i++) if (ch[i] == 0) r = i;
    pre(r); cout << "\n";
    in(r); cout << "\n";
    post(r); cout << "\n";
 
    return 0;
}
```

## 2. 아는 사람 (00:11:44)

분리 집합으로 쉽게 풀 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
 
int n, q, root[101010];
 
int _find(int v) {
    if (v == root[v]) return v;
    else return root[v] = _find(root[v]);
}
 
int _union(int v, int u) {
    v = _find(v);
    u = _find(u);
    if (v == u) return 1;
    root[v] = u;
    return 0;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n; i++) root[i] = i;
 
    cin >> q;
    while (q--) {
        int t, u, v;
        cin >> t >> u >> v;
        if (t == 0) _union(u, v);
        if (t == 1) {
            if (_find(u) == _find(v)) cout << "1\n";
            else cout << "0\n";
        }
    }
 
    return 0;
}
```

## 3. 생각하는 힙 (00:38:55)

가능한 경우를 구성적으로 찾자. 상황을 단순화하기 위해 완성된 이진 트리에서 $i$번째 인덱스에 위치하는 값을 $i$번째에 넣는다고 하자. 모든 이진 트리에 대해 넣는 순서가 존재하기 때문에 이렇게 해도 불가능할 조건과 가능할 조건이 바뀌지 않음이 보장된다.

- $p$번 노드보다 항상 커야 하는 수: $p$번 노드를 부분 트리에 포함하는 노드에는 $p$보다 큰 수가 들어가야 한다. 따라서 루트에서 $p$번 노드로 가는 경로를 $1, 2, \cdots$로 차례로 채우자. 이 과정에서 $p$번 노드의 최솟값이 결정되며 이 값보다 $k$가 작으면 불가능하다.
- $p$번 노드보다 항상 작아야 하는 수: $p$번 노드의 부분 트리에는 항상 $p$보다 작은 수가 온다. 재귀적으로 상하 관계가 만족되도록 적당히 채우자. 만약 $k$보다 큰 수가 $p$번 노드의 부분 트리에 올 수 있는 수보다 적다면 불가능하다.
- 나머지 수: 인덱스 상으로 뒤로 위치할수록 더 큰 수로 배열하면, 절대 대소관계를 위배하지 않음을 알 수 있으므로 나머지 수를 인덱스 상으로 뒤쪽에 큰 수가 들어가도록 채운다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, p, ans[202020], ch[202020];
vector<int> vec;
 
void up(int v, int m) {
    if (v == 0) return;
    ans[v] = m;
    up(v/2, m-1);
}
 
void down(int v) {
    if (v > n) return;
    if (k > n) {
        cout << "-1\n";
        exit(0);
    }
    ans[v] = k++;
    down(2 * v);
    down(2 * v + 1);
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> k >> p;
 
    if ((int)log2(p) >= k) {
        cout << "-1\n";
        exit(0);
    }
    up(p/2, (int)log2(p));
    down(p);
 
    for (int i = 1; i <= n; i++) ch[ans[i]] = 1;
    for (int i = 1; i <= n; i++) if (ch[i] == 0) vec.push_back(i);
    int p = 1;
    for (int i = 0; i < vec.size(); i++) {
        while (ans[p] > 0) p++;
        ans[p] = vec[i];
        ch[p] = 1;
    }
 
    for (int i = 1; i <= n; i++) cout << ans[i] << "\n";
 
    return 0;
}
```

## 4. 후위순회 복원 (01:15:41)

어떤 트리의 전위순회상 첫번째 노드가 루트이고, 중위순회상으로 그 노드의 왼쪽 부분배열이 왼쪽 부분 트리, 오른쪽 부분배열이 오른쪽 부분 트리이다. 따라서, 원래 트리에서 전위순회상 구간과 중위순회상 구간을 넘겨 부분 트리를 표시하면 왼쪽 노드와 오른쪽 노드를 알 수 있다. 이를 이용해 후위순회를 구하면 문제가 해결된다.

문제는 중위순회상에서 루트 노드를 앞에서부터 찾는다면 최악의 경우 $O(N^2)$으로 TLE를 받는다는 점이다. 이를 위해 양쪽에서 하나씩 루트 노드인지 확인한다면 `smaller to larger` 테크닉으로 $O(N \log N)$의 시간에 해결할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, pre[1010101], in[1010101];
int lt[1010101], rt[1010101];
 
int solve(int s, int e, int l, int r) {
    //cout << s << e << l << r << "\n";
    int v = pre[s];
    if (s > e) return 0;
    if (s == e) return v;
 
    for (int i = l; i <= r; i++) {
        if (in[i] == v) {
            lt[v] = solve(s + 1, s + i - l, l, i - 1);
            rt[v] = solve(s + i - l + 1, e, i + 1, r);
            return pre[s];
        }
        int j = r + l - i;
        if (in[j] == v) {
            lt[v] = solve(s + 1, s + j - l, l, j - 1);
            rt[v] = solve(s + j - l + 1, e, j + 1, r);
            return pre[s];
        }
    }
}
 
void pos(int v) {
    if (v == 0) return;
    pos(lt[v]);
    pos(rt[v]);
    cout << v << " ";
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> pre[i];
    for (int i = 1; i <= n; i++) cin >> in[i];
 
    int root = solve(1, n, 1, n);
    
    //for (int i = 1; i <= n; i++) cout << i << " " << lt[i] << " " << rt[i] << "\n";
 
    pos(root);
 
    return 0;
}
```

## 5. Split the Attractions (01:28:31)

중앙값을 찾는 문제이다. 중앙값 이하를 저장하는 우선순위 큐와 중앙값 초과를 저장하는 우선순위 큐를 관리하면 $O(\log N)$에 값 추가를, $O(1)$에 중앙값 찾기를 할 수 있다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> pii;
int n, fun[101010];
priority_queue< pii, vector<pii>, greater<> > good;
priority_queue< pii > bad;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> fun[i];
    cout << fun[1] << "\n";
    if (fun[1] < fun[2]) { good.push({fun[2], -2}); bad.push({fun[1], -1}); }
    else { good.push({fun[1], -1}); bad.push({fun[2], -2}); }
    for (int i = 3; i <= n; i++) {
        if (i % 2 == 1) {
            if (fun[i] <= good.top().first) bad.push({fun[i], -i});
            else {
                bad.push(good.top());
                good.pop();
                good.push({fun[i], -i});
            }
            cout << bad.top().first << "\n";
        }
        if (i % 2 == 0) {
            if (fun[i] > bad.top().first) good.push({fun[i], -i});
            else {
                good.push(bad.top());
                bad.pop();
                bad.push({fun[i], -i});
            }
        }
    }
 
    return 0;
}
```

## 7. 개구리 (01:58:35)

주어지는 돌의 좌표 $(a, b)$는 $x$좌표가 $a$인 선에서 $y$좌표가 $b$인 선으로 넘어가거나, $y$좌표가 $b$인 선에서 $x$좌표가 $a$인 선으로 넘어가는 것으로 볼 수 있다. 즉, $x$좌표가 $a$인 상태와 $y$좌표가 $b$인 상태를 나타내는 두 정점을 가중치 $1$의 간선으로 이으면 된다.

모든 돌에 대해 이 과정을 거쳤을 때, 최대 $2N+4$개의 점과 $N+2$개의 간선으로 구성된 그래프를 얻을 수 있다. 이 그래프에서 다익스트라를 통해 최솟값을 구하면 그 값이 답이 된다.

처음 및 끝에서는 $x$축 및 $y$축 어디로도 올 수 있으므로 가능한 시작점과 가능한 끝점이 2개씩임에 유의해 가능한 네 쌍의 거리의 최솟값을 구해야 한다. 시간복잡도는 $O(N \log N)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, pos[101010][2], ans = 1e9;
 
vector<int> xlist, ylist;
 
vector< pair<int, int> > adj[202020];
int dis[202020];
 
priority_queue< pair<int, int> > pq;
void dijkstra(int st) {
    for (int i = 0; i < 2*n+4; i++) dis[i] = 1e9;
    while (!pq.empty()) pq.pop();
 
    dis[st] = 0;
    pq.push({-dis[st], st});
    while (!pq.empty()) {
        int now = pq.top().second, nowdis = -pq.top().first;
        pq.pop();
        for (int i = 0; i < adj[now].size(); i++) {
            int next = adj[now][i].first, w = adj[now][i].second;
            if (nowdis + w < dis[next]) {
                dis[next] = nowdis + w;
                pq.push({-dis[next], next});
            }
        }
    }
 
    ans = min(ans, dis[pos[n+1][0]]);
    ans = min(ans, dis[pos[n+1][1] + n + 2]);
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    cin >> pos[0][0] >> pos[0][1] >> pos[n+1][0] >> pos[n+1][1];
    for (int i = 1; i <= n; i++) cin >> pos[i][0] >> pos[i][1];
 
    for (int i = 0; i <= n+1; i++) {
        xlist.push_back(pos[i][0]);
        ylist.push_back(pos[i][1]);
    }
 
    sort(xlist.begin(), xlist.end());
    xlist.erase(unique(xlist.begin(), xlist.end()), xlist.end());
    sort(ylist.begin(), ylist.end());
    ylist.erase(unique(ylist.begin(), ylist.end()), ylist.end());
 
    for (int i = 0; i <= n+1; i++) {
        pos[i][0] = lower_bound(xlist.begin(), xlist.end(), pos[i][0]) - xlist.begin();
        pos[i][1] = lower_bound(ylist.begin(), ylist.end(), pos[i][1]) - ylist.begin();
        adj[pos[i][0]].push_back({n + 2 + pos[i][1], 1});
        adj[n + 2 + pos[i][1]].push_back({pos[i][0], 1});
    }
 
    dijkstra(pos[0][0]);
    dijkstra(pos[0][1] + n + 2);
 
    if (ans < 1e9) cout << ans << "\n";
    else cout << "-1\n";
 
    return 0;
}
```

## 8. 커닝시티 (04:08:58)

기본적으로 오프라인 쿼리로 해결할 것이다. $p$를 줄여가면서 간선을 하나씩 연결하고, 이를 분리 집합으로 처리한다. 이 `find(v)`와 `union(u, v)`에서 답을 구하기 위한 추가 작업을 하면 맞을 수 있다. 이제 그 추가 작업을 논의해보자.

관찰을 해보면 압축 전후에 $2$개의 간선으로 연결된 정점의 개수만큼 정점의 개수와 간선의 개수가 줄어든다는 사실을 파악할 수 있다. 그 이유는 압축을 하더라도 사라지지 않은 정점은 연결된 간선의 개수가 변하지 않기 때문이다.

유일한 예외는, 어떤 컴포넌트가 완전한 사이클을 이룰 때이다. 정확히 말하면 모든 정점이 정확히 2개의 간선과 연결되는 경우이다. 이 경우에는 하나의 간선과 하나의 정점이 남으므로 이러한 컴포넌트의 개수만큼 정점의 개수와 간선의 개수에 더해 보정해주어야 한다.

고로 우리가 처리해주어야 하는 것은 아래 네 가지이다:

- 압축 전 간선 개수: 한번 `union(u, v)`를 할 때 1 증가
- 어떤 간선도 연결되지 않은 정점을 제거한 이후 정점 개수: `cnt[v]`가 $0$인 정점이 합쳐질 때 1 증가
- $2$개의 간선으로 연결된 정점 개수: 인접행렬에 간선을 추가하면서 `adj[v]`의 크기가 1에서 2가 되면 1 증가, 2에서 3이 되면 1 감소
- 완전한 사이클을 이루는 컴포넌트의 개수: 각 컴포넌트의 루트에 그 컴포넌트 안의 간선 개수의 합과 최댓값을 저장해, 최댓값이 2이고 합이 정점 개수와 동일할 때 1이다. 컴포넌트의 변화가 있을 때마다 확인하자.

아래는 구현 코드이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
 
int n, m, q;
struct edge {
    int u, v;
}; 
vector<edge> edges[303030];
vector<int> adj[303030];
vector< pair<int, int> > query;
int two = 0, cycle = 0, ns = 0, ms = 0;
int root[303030], cnt[303030], link[303030], maxadj[303030], iscycle[303030];
int ans[303030][2];
 
int _find(int v) {
    if (v == root[v]) return v;
    else return root[v] = _find(root[v]);
}
 
void change(int v) {
    cycle -= iscycle[v];
    if (maxadj[v] == 2 && link[v] == cnt[v]) iscycle[v] = 1;
    else iscycle[v] = 0;
    cycle += iscycle[v];
}
 
void _union(int v, int u) {
    v = _find(v);
    u = _find(u);
    if (v == u) {
        link[v]++;
        change(v);
        return;
    }
    if (cnt[v] == 1) ns++;
    if (cnt[u] == 1) ns++;
    root[v] = u;
    cnt[u] += cnt[v];
    link[u] += link[v] + 1;
    maxadj[u] = max(maxadj[v], maxadj[u]);
    cycle -= iscycle[v];
    iscycle[v] = 0;
    change(u);
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        edges[c].push_back({a, b});
    }
 
    cin >> q;
    for (int i = 0; i < q; i++) {
        int p;
        cin >> p;
        query.push_back({p, i});
    }
 
    sort(query.begin(), query.end(), greater< pair<int, int> >());
 
    int p = 300000;
    for (int i = 1; i <= n; i++) root[i] = i;
    for (int i = 1; i <= n; i++) cnt[i] = 1;
    for (int i = 1; i <= n; i++) link[i] = 0;
    for (int i = 1; i <= n; i++) maxadj[i] = 0;
    for (int i = 0; i < q; i++) {
        while (p >= query[i].first) {
            for (int j = 0; j < edges[p].size(); j++) {
                adj[edges[p][j].u].push_back(edges[p][j].v);
                adj[edges[p][j].v].push_back(edges[p][j].u);
                if (adj[edges[p][j].u].size() == 2) two++;
                if (adj[edges[p][j].u].size() == 3) two--;
                if (adj[edges[p][j].v].size() == 2) two++;
                if (adj[edges[p][j].v].size() == 3) two--;
                int u = _find(edges[p][j].u), v = _find(edges[p][j].v);
                maxadj[u] = max(maxadj[u], (int)adj[edges[p][j].u].size());
                maxadj[v] = max(maxadj[v], (int)adj[edges[p][j].v].size());
                _union(edges[p][j].u, edges[p][j].v);
                ms++;
            }
            p--;
        }
        ans[query[i].second][0] = ns - two + cycle;
        ans[query[i].second][1] = ms - two + cycle;
    }
 
    for (int i = 0; i < q; i++) cout << ans[i][0] << " " << ans[i][1] << "\n";
 
    return 0;
}
```

## 6. BST 만들기

수열 $A$와 수열 $B$를 모두 사용하려면 정렬 순서를 알아야 하므로 비효율적이다. 따라서 하나만 사용하자. 만약 수열 $A$를 사용하는 경우에는 $O(N \log N)$ 이하의 시간에 구현할 수 없으므로 자연히 수열 $B$를 사용해야 한다는 결론을 얻을 수 있다.

수열 $B$를 사용해 $0$번부터 $N-1$번까지 순서대로 넣는 상황을 생각하자. $i$번째 정점을 넣을 때 $b_i$와 $b_{i-1}$을 비교해 $i$와 $i-1$의 대소를 따지고, 만약 $i$가 앞에 나왔다면 위로 올리자. 이 과정을 반복하면 $2N-3$번의 비교로 문제가 해결된다. 증명은 아래와 같다:

- 각 $i$에 대해 $i-1$과 한 번 비교한다. 총 $N-1$번이다.
- 만약 추가 비교가 일어나게 되면, 루트로부터 리프노드까지의 거리가 $1$ 증가한다. 처음 $1$이고, 최대 $N-1$이 가능하므로 추가 비교 횟수는 $N-2$번 이하이다.

```cpp
#include "buildbst.h"
#include <bits/stdc++.h>
using namespace std;

int lt[303030], rt[303030], par[303030];
int ch[303030], dep[303030];

void solve(int v, int d) {
	if (v == -1) return;
	dep[v] = d;
	solve(lt[v], d + 1);
	solve(rt[v], d + 1);
}

vector<int> buildbst(int N) {
	for (int i = 0; i < N; i++) par[i] = lt[i] = rt[i] = -1;
	int root = 0;

	for (int i = 1; i < N; i++) {
		int t = i - 1;
		while (t >= 0) {
			//cout << t << " " << i << "\n";
			if (compare('B', t, i)) {
				par[rt[t]] = i;
				lt[i] = rt[t];
				par[i] = t;
				rt[t] = i;
				break;
			}
			else t = par[t];
		}
		if (t == -1) {
			par[root] = i;
			lt[i] = root;
			root = i;
		}
	}

	//for (int i = 0; i < N; i++) std::cout << lt[i] << " " << rt[i] << "\n";

	solve(root, 0);
	vector<int> ans;
	for (int i = 0; i < N; i++) ans.push_back(dep[i]);
	return ans;
}
```