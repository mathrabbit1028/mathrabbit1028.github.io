---
title: 2023학년도 정보올림피아드 여름학교 2일차
author: mathrabbit
date: 2023-08-03 12:00:00 +0900
categories: [Problem Solving, 2023 여름학교]
tags: [camp]
math: true
---

2024-08-03 : 2024s-02 [정렬과 탐색]

[문제지](https://drive.google.com/drive/folders/1F26jnFVUxfZSaMYOHqL-ceVrnpQLqCHQ?usp=sharing)

## 1. 정렬하기 (00:05:51)

$O(N \log N)$인 머지 소트를 구현하였다.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, arr[202020];
int temp[202020];

void msort(int st, int ed) {
    if (st == ed) return;
    int mid = (st + ed) / 2;
    msort(st, mid);
    msort(mid + 1, ed);
    int p = st, q = mid + 1, r = st;
    while (true) {
        if (p > mid && q > ed) break;
        if (p > mid) {
            temp[r++] = arr[q++];
            continue;
        }
        if (q > ed) {
            temp[r++] = arr[p++];
            continue;
        }
        if (arr[p] < arr[q]) temp[r++] = arr[p++];
        else temp[r++] = arr[q++];
    }
    for (int i = st; i <= ed; i++) arr[i] = temp[i];
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i <= n; i++) cin >> arr[i];

    msort(1, n);

    for (int i = 1; i <= n; i++) cout << arr[i] << " ";
    cout << "\n";

    return 0;
}
```

## 2. 나무 자르기 (00:12:31)

[백준](https://www.acmicpc.net/problem/2805)에서도 가장 유명한 매개변수 탐색 문제로, $O(N \log M)$에 해결 가능하다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, arr[1010101];
ll m;
 
ll tree(int cut) {
    ll ret = 0;
    for (int i = 1; i <= n; i++) if (arr[i] > cut) ret = ret + arr[i] - cut;
    return ret;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> arr[i];
 
    int st = 0, ed = 1e9;
    while (st < ed) {
        int mid = (st + ed + 1) / 2;
        if (tree(mid) < m) ed = mid - 1;
        else st = mid;
    }
 
    cout << st << "\n";
 
    return 0;
}
```

## 3. 교차하는 선분 (00:21:12)

$i<j$지만 $a_i>a_j$인 개수를 찾는 문제다. 분할 정복, 세그먼트 트리 등 다양한 방식을 사용할 수 있다. $O(N \log N)$에 구현하기만 하면 된다. 아래는 세그먼트 트리를 이용한 구현이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, arr[505050];
ll ans = 0;

ll tree[2020202];
void update(int v, int st, int ed, int idx, int val) {
    if (st > idx || ed < idx) return;
    if (st == idx && ed == idx) {
        tree[v] += val;
        return;
    }
    int mid = (st + ed) / 2;
    update(2 * v, st, mid, idx, val);
    update(2 * v + 1, mid + 1, ed, idx, val);
    tree[v] = tree[2 * v] + tree[2 * v + 1];
}

ll get(int v, int st, int ed, int lt, int rt) {
    if (st > rt || ed < lt) return 0;
    if (lt <= st && ed <= rt) return tree[v];
    int mid = (st + ed) / 2;
    return get(2 * v, st, mid, lt, rt) + get(2 * v + 1, mid + 1, ed, lt, rt);
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i <= n; i++) cin >> arr[i];

    for (int i = 1; i <= n; i++) {
        ans += get(1, 1, n, arr[i] + 1, n);
        update(1, 1, n, arr[i], 1);
    }

    cout << ans << "\n";

    return 0;
}
```

## 4. 롤러코스터 (00:30:19)

$(a, b)$를 적용하고 $(c,d)$를 적용한 경우와 반대로 적용한 경우의 식을 비교해보면 $bc + d > ad + b$인 경우 $(a, b)$를 먼저 적용하는 경우 값이 더 크다. 즉, 그리디하게 $bc+d>ad+b$인 레일을 먼저 적용하는 것이 유리함을 알 수 있다. 따라서 저 부등식을 기준으로 $O(N \log N)$의 시간에 정렬한 후 순서대로 처리하면 된다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define a first
#define b second
int n;
pair<ll, ll> arr[505050];
ll ans = 1, MOD = 1234567891;

bool compare(pair<ll, ll> p, pair<ll, ll> q) {
    return p.b * q.a + q.b > p.a * q.b + p.b;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i <= n; i++) cin >> arr[i].a >> arr[i].b;

    sort(arr + 1, arr + n + 1, compare);

    for (int i = 1; i <= n; i++) {
        ans = (ans * arr[i].a + arr[i].b) % MOD;
    }

    cout << ans << "\n";

    return 0;
}
```

## 6. 퇴교 (00:59:59)

가능한 정답률이 $x$ 이상인지 판별해보자. $\sum A_i - x \sum B_i \geq0$이면 정답률이 $x$ 이상일 수 있으므로, $A_i - xB_i$를 기준으로 정렬 후 값이 큰 $N-K$개의 합이 음이 아니면 $x$가 가능하다는 뜻이다.

유리수로 처리하는 것은 부동소숫점 문제를 일으킬 수 있으므로, 절대오차 $10^{-6}$까지 가능하다는 점에서 착안해 $x$ 대신 $10^6x$를 정수로 두어 매개변수 탐색을 한다. 이 과정에서 `sum`이 `long long` 범위를 넘어갈 수 있으므로 `__int128`을 이용해 처리하였다.

참고: [이 문제](https://www.acmicpc.net/problem/18342)의 2번 서브테스크의 풀이와 동일하다. 저 문제의 경우 쿼리가 있어 만점 풀이는 CHT를 사용해야 한다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define AC first
#define WA second
int n, k;
pair<ll, ll> arr[101010];
ll val;
 
bool compare(pair<ll, ll> p, pair<ll, ll> q) {
    return p.AC * 1000000 - val * p.WA < q.AC * 1000000 - val * q.WA;
}
 
bool can() {
    sort(arr + 1, arr + n + 1, compare);
    __int128 sum = 0;
    for (int i = k + 1; i <= n; i++) sum += arr[i].AC * 1000000 - val * arr[i].WA;
    if (sum >= 0) return true;
    else return false;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> arr[i].AC >> arr[i].WA;
 
    int st = 0, ed = 1000000;
    while (st < ed) {
        int mid = (st + ed + 1) / 2;
        val = mid;
        if (can()) st = mid;
        else ed = mid - 1;
    }
 
    printf("%.7f", st * 0.000001);
 
    return 0;
}
```

## 8. 정수 찾기 (01:24:33)

개수가 홀수인 정수가 최대 하나이므로, 구간 $[st, ed]$에 속하는 수의 개수가 홀수개이면, $[st, ed]$ 안에 답에 있음이 보장된다. 이를 이용해 매개변수 탐색을 하면 답을 구할 수 있다. 시간복잡도는 $O(N \log X)$이다.

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
ll arr[20202][3];
 
ll cnt(ll st, ll ed) {
    ll ret = 0;
    for (int i = 1; i <= n; i++) {
        if (ed < arr[i][0] || st > arr[i][1]) continue;
        ll s = max(st, arr[i][0]) - arr[i][0], e = min(ed, arr[i][1]) - arr[i][0];
        ret = ret + e / arr[i][2] - (s + arr[i][2] - 1) / arr[i][2] + 1;
    }
    return ret;
}
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
 
    for (int i = 1; i <= n; i++) cin >> arr[i][0] >> arr[i][1] >> arr[i][2];
 
    if (cnt(1, 2147483647) % 2 == 0) {
        cout << "NOTHING";
        return 0;
    }
 
    ll st = 1, ed = 2147483647;
    while (st < ed) {
        ll mid = (st + ed) / 2;
        if (cnt(st, mid) % 2 == 1) ed = mid;
        else st = mid + 1;
    }
 
    cout << st << " " << cnt(st, st) << "\n";
 
    return 0;
}
```

## 7. $K$번째 최솟값 찾기 (02:52:51)

정렬된 두 배열에서 $K$번째 최솟값을 찾는 문제이다. $N≤10^5$과 $Q≤19$에서 알 수 있듯이 $\log_2 n$의 시간에 해결할 수 있어야 한다.

먼저 $A_i < B_j$라는 답을 얻었다고 가정해보자. 그러면 $B_j > A_i > A_{i - 1} > \cdots > A_0$이고, $B_j > B_{j-1} > \cdots > B_0$이므로 $B_j$보다 작은 수는 적어도 $i+j+1$개 있다. 즉, $B_j$는 적어도 $i+j+2$번째로 작은 수이다.

여기서, 만약 $i+j = K - 1$이었다면, $B_j$는 $K$번째로 작은 수가 될 수 없으므로, $B$ 배열에서 $K$번째로 작은 수로 가능한 인덱스는 $j$ 미만임을 알 수 있다. 여기서 $i = K - j - 1$이므로 $A$ 배열에서 $K$번째로 작은 수로 가능한 인덱스는 현재 $i$ 이상임을 알 수 있다.

반대로, $A_i > B_j$라는 답을 얻었다고 가정해보면, $A_i$보다 작은 수는 적어도 $i+j+1 = K$개 있으므로 $K$번째로 작은 수로 가능한 인덱스는 $i$ 미만이다.

이렇게 얻은 $i$를 이용해 $A_i$와 $B_{K-i-2}$를 비교해 더 큰 쪽이 $K$번째 수이다. $K$의 범위에 따라 $i$값의 시작 범위 및 끝 범위가 달라짐에 유의하자.

```cpp
#include "search.h"
#include <bits/stdc++.h>
using namespace std;
 
int search(int N, int K) {
	int st, ed;
	if (K <= N) st = -1, ed = K - 1;
	else st = K - N - 1, ed = N - 1;
	while (st < ed) {
		int a = (st + ed + 1) / 2;
		if (compare(a, K - a - 1)) st = a;
		else ed = a - 1;
	}
 
	if (st == K - 1) return st;
	if (st == -1) return N + K - st - 2;
 
	if (compare(st, K - st - 2)) return N + K - st - 2;
	else return st;
}
```

## 5. Arranging Shoes

5종류의 가능한 상태가 주어지고, 한 번 위치가 바뀐 신발은 다시 바뀌지 않기 때문에, 3번 이상 인접하여 나타난 관계는 옳음이 보장된다. 즉, 3번 이상 인접하여 나타난 왼쪽 및 오른쪽 관계를 저장하고 이를 이용해 원래 나열을 구하면 된다.

예외가 되는 경우는 아래와 같이 3번 이상 인접한 관계만으로는 순환이 만들어지지 않는 경우인데, 이 경우에는 최대 한 군데에서 끊기고 연속됨이 보장되므로, 연속된 나열로 만들고 0부터 자르면 예외를 처리할 수 있다.

```
<예외>
7
1 7 2 3 4 5 6
1 6 2 3 4 5 7
1 5 2 3 4 6 7
1 4 2 3 5 6 7
1 3 2 4 5 6 7
```

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, arr[5][202020], lt[5][202020], rt[5][202020], res[202020][2], rev[202020], ch[202020];
vector<int> ans;
 
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    cin >> n;
    for (int i = 0; i <= n; i++) res[i][0] = res[i][1] = -1;
    for (int t = 0; t < 5; t++) {
        for (int i = 1; i <= n; i++) cin >> arr[t][i];
    }
 
    for (int t = 0; t < 5; t++) {
        for (int i = 1; i < n; i++) lt[t][arr[t][i]] = arr[t][i + 1];
        for (int i = 2; i <= n; i++) rt[t][arr[t][i]] = arr[t][i - 1];
    }
 
    for (int i = 1; i <= n; i++) {
        for (int t = 0; t < 5; t++) {
            int cnt = 0;
            for (int s = 0; s < 5; s++) if (lt[t][i] == lt[s][i]) cnt++;
            if (cnt >= 3) {
                res[i][0] = lt[t][i];
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int t = 0; t < 5; t++) {
            int cnt = 0;
            for (int s = 0; s < 5; s++) if (rt[t][i] == rt[s][i]) cnt++;
            if (cnt >= 3) {
                res[i][1] = rt[t][i];
            }
        }
    }
 
    for (int t = 0; t < 5; t++) {
        int cnt = 0;
        for (int s = 0; s < 5; s++) if (arr[t][1] == arr[s][1]) cnt++;
        if (cnt >= 3) {
            res[0][0] = arr[t][1];
        }
    }
    for (int t = 0; t < 5; t++) {
        int cnt = 0;
        for (int s = 0; s < 5; s++) if (arr[t][n] == arr[s][n]) cnt++;
        if (cnt >= 3) {
            res[0][1] = arr[t][n];
        }
    }
 
    //for (int i = 0; i <= n; i++) cout << res[i][0] << " "; cout << "\n";
    //for (int i = 0; i <= n; i++) cout << res[i][1] << " "; cout << "\n";
 
    int p = 0;
    for (int i = 1; i <= n; i++) if (res[i][1] == -1) p = i;
 
    ans.push_back(p);
    for (int i = 1; i <= n; i++) {
        p = res[p][0];
        ans.push_back(p);
    }
 
    int q = 0;
    for (int i = 0; i <= n; i++) if (ans[i] == 0) q = i;
    for (int i = q + 1; i <= n; i++) cout << ans[i] << " ";
    for (int i = 0; i < q; i++) cout << ans[i] << " ";
 
    return 0;
}
```